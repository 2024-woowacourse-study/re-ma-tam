# 4장 - 아키텍처

## MySQL의 엔진

MySQL은 MySQL 엔진과 스토리지 엔진으로 구분된다.

# 4.1 MySQL 엔진 아키텍처

MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특하다.
사용자 입장에서 보면 거의 차이가 느껴지지 않지만 이러한 독특한 구조 덕분에
타 DBMS에서 가질 수 없는 엄청난 혜택을 누린다.

> 반대로 다른 DBMS에서는 문제가 되지 않을 것들이 문제가 되기도 한다.
> 

MySQL의 쿼리를 작성하고 튜닝할 때 필요한 기본적인 MySQL 엔진 구조를 흝어보자

## 4.1.1 MySQL의 전체 구조

![스크린샷 2024-08-07 20.44.12.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-07_20.44.12.png)

### 다양한 프로그래밍 언어 지원

- MySQL은 일반 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원한다.
- MySQL 고유의 C API부터 시작해서 JDBC, ODBC, .NET의 표준 드라이버를 제공하며,
이러한 드라이버를 이용해 C/C++, PHP, 자바, 펄 루비 등의 모든 언어로 MySQL 서버에서 쿼리를 사용할 수 있게 지원한다.

### MySQL엔진과 스토리지 엔진

- *MySQL의 SQL 파서나 옵티마이저 등과 같은 기능을 스토리지 엔진과 구분하고자*
**MySQL 엔진** 과 **스토리지 엔진**을 구분했다.
- 그리고 이 둘을 합쳐서 `MySQL` 또는 `MySQL 서버` ****라고 표현한다.

<aside>
🚀 **[궁금 포인트]
SQL 파서나 옵티마이저 등의 기능을 스토리지 엔진과 구분하고자 엔진을 두 개로 분리하였는데, 그렇게 분리해서 어떤 이점을 얻을 수 있는가?**

대답) 데이터 관련 작업을 담당하는 스토리지 엔진은 MySQL 엔진과 분리됨과 동시에 여러개의 엔진 중 용도에 맞는 엔진을 선택하여 사용할 수 있게 개발되었다.
그러한 스토리지 엔진을 애플리케이션의 요구사항에 맞게 선택하거나, 직접 엔진을 개발하여
요구사항에 대한 성능을 높이고 효율적으로 데이터를 처리를 할 수 있도록 두 엔진을 분리한 것으로 생각된다.

</aside>

## 4.1.1.1 MySQL 엔진

> 단 하나의 엔진만 사용하며 **머리 역할**을 담당
> 

MySQL 엔진은 접속 및 쿼리 요청을 처리하는 `커넥션 핸들러` 와
`SQL 파서` , `전처리기` , 쿼리의 최적화된 실행을 위한 `옵티마이저` 가 주를 이룬다.

> MySQL은 표준 SQL(ANSI SQL) 문법을 지원하기 때문에
*표준 문법으로 작성된 쿼리는 타 DBMS와 호환*되어 실행될 수 있다.
> 

## 4.1.1.2 스토리지 엔진

> 다수의 엔진 사용 가능하며 **손발 역할**을 담당
> 
- *핸들러 API를 만족하면* 누구든 **스토리지 엔진을 구현해서 MySQL 서버에 추가** 해서 사용 가능

MySQL에서 두뇌의 역할에 관련된 내용은 MySQL 엔진이 처리하는 반면
디스크 스토리지에서 실제 데이터를 저장, 불러오기 등의 역할은 스토리지 엔진이 담당한다.

MySQL서버에서 MySQL 엔진은 단 하나인 반면
MySQL에서 스토리지 엔진은 여러 개가 존재할 수 있으며 사용할 수 있다.

```sql
# InnoDB 스토리지 엔진을 사용하는 test_table을 생성하는 명령
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=InnoDB;
```

각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다.

## 4.1.1.3 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기 요청을 보낸다.

- 이때 요청을 `핸들러(Handler) 요청`
- 여기서 사용되는 API를 `핸들러 API` 라고 한다.

이 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지는 아래 명령으로 확인할 수 있다.

```sql
# 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지 조회
SHOW GLOBAL STATUS LIKE `Handler%`;
```

![스크린샷 2024-08-07 21.12.30.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-07_21.12.30.png)

---

## 4.1.2 MySQL 스레딩 구조

![스크린샷 2024-08-07 21.13.43.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-07_21.13.43.png)

- MySQL 서버는 프로세스 기반이 아닌, `스레드 기반` 으로 작동
- 스레드는 크게 `포그라운드(Foreground) 스레드` 와 `백그라운드(Background) 스레드` 로 구분

MySQL 서버에서 실행 중인 스레드의 목록은 다음과 같이 **performance_schema** 데이터베이스의 **threads** 테이블을 통해 확인할 수 있다.

```sql
SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER BY type, thread_id;
```

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/Untitled.png)

![스크린샷 2024-08-07 21.24.21.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-07_21.24.21.png)

조회를 하니 총 40개의 쓰레드가 실행 중인데, 그 중 3개만 포그라운드 스레드로 표시되어 있다.

> 백그라운드 스레드의 개수는 MySQL 서버 설정 내용에 따라 가변적이다.
> 

3개의 포그라운드 스레드 중, 마지막 `thread/sql/one_connection` 스레드만 실제 사용자의 요청을 처리하는 포그라운드 스레드이다.

![스크린샷 2024-08-07 21.27.24.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-07_21.27.24.png)

동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버 설정에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다.

<aside>
📃 여기서 알아본 스레드 모델은 전통적인 MySQL 서버의 스레드 모델이며, 커뮤니티 에디션에서 사용되는 모델이다.
’MySQL 엔터프라이즈 에디션’과 ‘Percona MySQL 서버’ 에서는 전통적인 스레드 모델 뿐만 아니라 **쓰레드 풀(Thread Pool)** 모델을 사용할 수도 있다.

전통적인 스레드 모델은 커넥션 별로 포그라운드 스레드가 하나씩 생성되어 할당된다.
하지만 스레드 풀에서는 커넥션과 포그라운드 스레드는 1:1 관계가 아니라 하나의 스레드가 여러 개의 커넥션 요청을 전담한다.
(자세한 내용은 4.1.9절 참조)

</aside>

## 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

주로 각 클라이언트가 요청하는 쿼리 문장을 처리하는 포그라운드 스레드는 *최소 MySQL 서버에 접속된 클라이언트의 수만큼 존재*

### 쓰레드 캐시(Thread cache)

클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 **스레드 캐시(Thread cache)** 로 되돌아간다.

이때 스레드 캐시는 **thread_cache_size** 시스템 변수에 설정된 만큼만 스레드를 가질 수 있는데, 해당 수만큼 이미 스레드가 존재한다면 캐시에 넣지않고 그대로 종료시켜 스레드 개수를 유지한다.

<aside>
🚀 **[궁금 포인트]
스레드 캐시의 스레드는 언제 삭제되는가, 영구적으로 유지되는가?**

MySQL 공식 문서에는 스레드 캐시가 얼마만큼 유지되는지에 대해 작성되어 있는 부분이 없다.
아마 스레드 캐시에 들어간 포그라운드 스레드는 계속해서 유지되다가
이후에 커넥션이 발생하면서 외부로 나갔다가 캐시로 돌아왔을 때, 캐시에 공간이 없으면 삭제되는 것 같다.

</aside>

<aside>
🚀 **[궁금 포인트]
캐시가 비어있는 시간동안 스레드는 클라이언트의 요청 마다 생성되는가?**

현재 매커니즘으로 보면 스레드는 캐시가 비어있는 경우라면 요청마다 생성되지 않을까 싶다.

DB에서 오랜 시간이 걸리는 작업 요청이 잦은 서비스의 경우에는
**thread_cache_size** 가 작게 설정되면 작업중인 쓰레드가 많아 쓰레드 캐시가 비어있는 시간이 자주 발생할 것이고, 그에 따라 쓰레드의 생성 및 삭제가 잦아져 캐시의 사용 이점을 얻을 수 없을 것이다.
이 부분을 고려해서 서비스의 환경에 따라 **thread_cache_size** 를 설정해볼 수 있을 것 같다고 생각했다.

</aside>

### 포그라운드 스레드의 ‘데이터 읽기’

포그라운드 스레드는 데이터를 `MySQL의 데이터 버퍼` 나 `캐시` 로 부터 가져오는데,
해당 공간에 데이터가 없는 경우 직접 **디스크의 데이터** 나 **인덱스 파일** 로부터 데이터를 읽어와 작업을 처리한다.

### 포그라운드 스레드의 ‘데이터 쓰기’

읽기 작업은 모두 포그라운드 스레드가 처리하지만, 쓰기 작업은 스토리지 엔진에 따라 차이가 있다.

스토리지 엔진이 **MyISAM** 인 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만,

**InnoDB** 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

> MyISAM도 지연된 쓰기가 있지만 일반적인 방식은 아니다.

**MyISAM의 지연된 쓰기란?**
디스크 쓰기 작업이 발생했을 때, 포그라운드 스레드가 데이터 버퍼나 캐시까지만 데이터를 담아두었다가 특정 조건이 만족되었을 때 디스크에 한 번에 플러시(Flush)하는 작업
> 

<aside>
📃 MySQL 에서 사용자 스레드와 포그라운드 스레드는 동일한 의미로 사용된다.
클라이언트가 MySQL 서버에 접속하게 되면 MySQL 서버는 그 클라이언트의 요청을 처리해 줄 스레드를 생성해 클라이언트에게 할당한다.

이 스레드는 DBMS의 앞단에서 사용자와 통신하기 때문에
**’포그라운드 스레드’** 라고 하며, 사용자가 요청한 작업을 처리하기 때문에 **‘사용자 스레드’** 라고도 한다.

</aside>

## 4.1.2.2 백그라운드 스레드

MyISAM의 경우 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같은 작업이 백그라운드로 처리된다.

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 락이나 데드락을 모니터링하는 스레드

모두 중요한 역할을 하지만, 그 중에서 가장 중요한 것은 **로그 스레드(Log thread)** 와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드(Write thread)** 일 것이다.

<aside>
🚀 **[궁금 포인트]**
MyISAM은 왜 백그라운드를 잘 사용하지 않을까?
어떤 이점을 얻기 위해서일까?

</aside>

### 읽기/쓰기 쓰레드 개수

MySQL 5.5 부터 **데이터 쓰기 쓰레드** 와 **데이터 읽기 쓰레드** 의 개수를 `2개 이상` 지정할 수 있게 되었다.

- **innodb_write_io_threads** , **innodb_read_io_threads** 시스템 변수로 스레드 개수 설정 가능 (기본 값은 4)
    
    ![스크린샷 2024-08-07 21.59.15.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-07_21.59.15.png)
    

### 백그라운드에서는 쓰기 작업 요청 > 읽기 작업 요청

InnoDB에서도 데이터를 읽는 작업은 주로 포그라운드 스레드에서 처리하기 때문에 읽기 쓰레드는 많이 설정할 필요가 없지만,
쓰기 쓰레드는 아주 많은 작업을 백그라운드 쓰레드로 처리하기 때문에

- 일반적인 내장 디스크를 사용할 때는 `2~4` 정도로 설정
- DAS, SAN 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을만큼 충분히 설정

### 쓰기 작업 지연 성능 보완 (버퍼링)

사용자의 요청을 처리하는 도중 데이터의 읽기 작업은 절대 지연될 수 없지만 (SELECT 쿼리를 실행했는데, 요청된 SELECT는 10분 뒤에 결과를 돌려주겠다고 말하는 DBMS는 없다),
데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있다.

일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 또한 이러한 방식으로 처리한다.

이러한 이유로 InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.

하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어있다.

- MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

<aside>
📃 **버퍼링이란?**

어떤 정보를 [버퍼](https://namu.wiki/w/%EB%B2%84%ED%8D%BC)(임시 저장소)에 저장하는 작업을 하고 있다는 뜻이다. 이 작업이 끝나기 전에는 정말 위급하거나 예외 상황이 아니면 출력을 하지 않는다.

InnoDB에서는 **버퍼 풀** 을 사용하여 버퍼링을 구현한다.

</aside>

### **InnoDB의 쓰기 버퍼링**

- **InnoDB**는 트랜잭션을 지원하는 고급 스토리지 엔진이다. InnoDB는 데이터를 쓰기 전에 **버퍼 풀**에 먼저 저장한다. 이 버퍼 풀은 메모리에 상주하며, 쓰기 작업이 발생할 때마다 데이터를 디스크에 직접 쓰는 대신, 이 버퍼에 저장해 둔다.
- 그런 다음, InnoDB의 **백그라운드 스레드**가 이 버퍼에 저장된 데이터를 디스크에 비동기적으로 기록한다. 이는 **쓰기 작업을 지연시키고 일괄 처리**하는 방식으로, 디스크 I/O를 최적화하고 성능을 높인다.
- 이로 인해 InnoDB에서는 사용자가 INSERT, UPDATE, DELETE 쿼리를 실행하더라도, 데이터가 디스크에 완전히 기록될 때까지 기다릴 필요가 없다. 데이터를 먼저 메모리에 저장하고, 이후에 디스크에 기록하기 때문이다.

### **MyISAM의 쓰기 방식**

- **MyISAM**은 InnoDB와 달리 **단순한 스토리지 엔진**입니다. MyISAM은 트랜잭션을 지원하지 않으며, 쓰기 작업에 대해 **버퍼링을 하지 않는다.**
- 즉, MyISAM에서 INSERT, UPDATE, DELETE와 같은 쿼리를 실행할 때, 이 작업은 **즉시 디스크에 기록된다.** 포그라운드 스레드가 이 작업을 처리하며, 버퍼에 데이터를 저장해 두었다가 나중에 일괄적으로 처리하는 것이 아니라, 요청이 발생하면 즉시 디스크에 쓰는 방식으로 동작한다.
- **결과적으로** MyISAM에서는 쓰기 작업이 완료될 때까지 사용자가 대기해야 한다. 이 때문에 쓰기 성능이 InnoDB보다 낮을 수 있으며, 대규모 쓰기 작업이 많은 경우 MyISAM은 InnoDB만큼 효율적이지 않을 수 있다.

---

## 4.1.3 메모리 할당 및 사용 구조

![스크린샷 2024-08-11 18.36.39.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_18.36.39.png)

MySQL의 메모리 공간은 크게 `글로벌 메모리 영역`과 `로컬 메모리 영역`으로 구분되어 있다.

<aside>
📃 **[둘의 구분 기준]**
MySQL 서버 내에 존재하는 *많은 스레드가 공유해서 사용하는 공간인지에 대한 여부*

</aside>

## 4.1.3.1 글로벌 메모리 영역

![스크린샷 2024-08-11 18.48.32.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_18.48.32.png)

- **사용 공간:** 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
    - 필요에 따라 2개 이상의 메모리 공간도 할당받을 수 있음.
        - 개수가 몇 개이던 모든 글로벌 메모리 영역은 모든 스레드에게 전역적으로 공유됨
- **메모리 할당:** MySQL 서버가 시작되는 시점에 운영체제로부터 할당
- **메모리 할당량:** 요청된 메모리 공간을 100% 할당할 수도 있고 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다. (운영체제마다 조금씩 다르다.)
- **메모리 사용량 측정:** MySQL의 시스템 변수로 설정해둔 값만큼 운영체제로부터 메모리를 할당받는다고 생각하면 된다. (MySQL 서버가 사용하는 정확한 메모리 양 측정은 쉽지 않다.)

### 대표적인 글로벌 메모리 영역

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

## 4.1.3.2 로컬 메모리 영역 (세션 메모리 영역 OR 클라이언트 메모리 영역)

![스크린샷 2024-08-11 18.48.26.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_18.48.26.png)

MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역

- **이름:**
    - 클라이언트 메모리 영역: 클라이언트 스레드가 사용하는 메모리 공간이기 때문에 로컬 메모리 영역을 클라이언트 메모리 영역이라고도 부른다.
    - 세션 메모리 영역: 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 부른다.
- **메모리 할당:** 클라이언트 커넥션으로부터의 요청을 처리하기 위해 할당됨
    - 각 클라이언트 스레드 별로 독립적으로 할당되며, 절대 공유되어 사용되지 않음
    - 쿼리의 용도별로 필요할 때만 공간이 할당되고, 메모리가 필요하지 않은 경우 할당조차 되지 않을 수도 있음
        - 로컬 메모리 공간은 커넥션이 열려있는 동안 계속해서 할당 상태로 있는 공간(커넥션 버퍼나 결과 버퍼)도 있고,
        쿼리를 실행하는 순간에만 할당 후 해제하는 공간(소트 버퍼나 조인 버퍼)도 있다.
- **메모리 할당량:** 일반적으로 글로벌 메모리 영역 크기는 주의해서 설정하지만
로컬 메모리 영역은 크게 신경쓰지 않고 설정하는데 *로컬 메모리 또한 각별한 주의가 필요*하다.
최악의 경우(가능성은 희박) MySQL 서버가 메모리 부족으로 멈춰 버릴 수도 있다.

### 대표적인 로컬 메모리 영역

- 정렬(Sort) 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

---

## 4.1.4 플러그인 스토리지 엔진 모델

![스크린샷 2024-08-11 18.58.50.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_18.58.50.png)

MySQL의 독특한 구조 중 대표적인 것이 바로 플러그인 모델이다.

### 플러그인을 통해 사용할 수 있는 것

- 스토리지 엔진
    - 스토리지 엔진이 플러그인으로 구현되기 때문에, 세상의 다양한 데이터를 처리하기 위해 특화된 또다른 스토리지 엔진을 직접 만들어서 사용하는 것이 가능하다.
- 검색 엔진을 위한 검색어 파서(인덱싱할 키워드를 분리해내는 작업)
- 쿼리 재작성
- 사용자 인증을 위한 Authentication (Native Authentication, Caching SHA-2 Authentication 등..)
- 커넥션 제어

이 뿐만 아니라, 기존 MySQL 서버에서 제공하던 기능들을 확장하거나 완전히 새로운 기능들을 플러그인을 통해 구현 가능

자세한 메뉴얼은 [여기](https://dev.mysql.com/doc/refman/8.0/en/server-plugins.html)를 참조

### 스토리지 엔진의 영향 범위

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/Untitled%201.png)

스토리지 엔진은 위 MySQL의 동작 영역에서, `데이터 읽기/쓰기` 부분만 담당한다.

플러그인을 통해 다른 스토리지 엔진을 적용하면 딱 해당 부분에만 변경이 발생한다.

<aside>
📃 **[데이터 읽기/쓰기 작업]**
데이터 읽기 쓰기 작업은 대부분 **`1건`**의 레코드 단위(예를 들어, 특정 인덱스의 레코드 1건 읽기 또는 마지막으로 읽은 레코드의 당므 또는 이전 레코드 읽기 등)로 처리된다.

</aside>

### 핸들러(Handler)

MySQL을 사용하다 보면 핸들러라는 단어를 자주 접하게 될 것이다.

MySQL에서 MySQL엔진은 **운전자** 역할을 하고, 스토리지 엔진 **자동차**의 역할을 하는데
MySQL엔진이 스토리지 엔진을 조정하기 위해 핸들러라는 것을 사용하게 된다.

여기서 핸들은 자동차를 조종하기 위해 필요한 **핸들** 같은 것이다.

> MySQL에서 핸들러라는 것은 개념적인 내용이어서 완전히 이해하지 못하더라도 크게 문제는 없다.
하지만 *MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면
반드시 핸들러(Handler)를 사용해야한다*는 점만은 기억하자.
> 

<aside>
📃 **[Handler 상태변수]**
나중에 서버의 `상태 변수` 라는 것을 배울 텐데,
이러한 상태 변수 중 **‘Handler_’** 로 시작하는 것이 많다는 사실을 알게 될 것이다.

**‘Handler_’** 로 시작하는 상태변수는 ‘MySQL 엔진이 각 스토리지 엔진에게 명령을 보낸 횟수를 의미하는 변수’ 라고 이해하면 된다.

</aside>

### 스토리지 엔진의 동작 차이

스토리지 엔진은 `데이터 읽기/쓰기`만 담당하기 때문에
하나의 쿼리의 전체적인 실행 과정에 있어서 스토리지 엔진 별로 큰 차이가 느껴지지 않을 수 있다.

하지만 이후 내용을 보다보면 스토리지 엔진 별로 `데이터 읽기/쓰기` 처리가 얼마나 달라질 수 있는지
이후에 알게 될 것이다.

지금 시점에서 중요하게 생각할 점은

<aside>
📃 하나의 쿼리 작업은 여러 개의 하위 작업으로 나뉘는데
이때 **각 하위 작업이 MySQL 엔진에서 처리되는지, 스토리지 엔진에서 처리되는지 구분할 줄 알아야 한다는 점이다.**

</aside>

이번 단락은 스토리지 엔진의 개념을 설명하기 위한 것도 있지만,
각 단위 작업을 누가 처리하고 ***MySQL 엔진 영역**과 **스토리지 엔진 영역**의 차이*를 설명하는 데 목적이 있다.

### MySQL 서버(mysqld)에서 지원되는 스토리지 엔진 확인하기

```sql
SHOW ENGINES;
```

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/Untitled%202.png)

- **Support 컬럼**
    - `YES`: MySQL 서버(mysqld)에 해당 스토리지 엔진이 포함되어 있고, 사용 가능으로 활성화도니 상태
    - `DEFAULT`: YES와 동일한 상태지만, 필수 스토리지 엔진임을 의미(즉, 이 스토리지 엔진이 없으면 MySQL이 시작되지 않을 수도 있다.)
    - `NO`: 현재 MySQL서버(mysqld)에 포함되지 않았음을 의미
    - `DISABLED`: 현재 MySQL 서버(mysqld)에는 포함됐지만 파라미터에 의해 비활성화된 상태

**플러그인 형태 스토리지 엔진의 장점**

1. **`즉시 사용 가능`**: MySQL 서버에 포함되지 않은 스토리지 엔진(Support 컬럼이 NO인)을 사용하려면 MySQL 서버를 다시 빌드(컴파일) 해야한다.
하지만 MySQL 서버가 적절히 준비되어있다면 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워넣기만 하면 바로 사용 가능하다.
2. **`손쉬운 업그레이드`**: 플러그인 형태의 스토리지 엔진은 업그레이드가 손쉽게 가능하다.
    
    

스토리지 엔진을 포함한 모든 플러그인은 아래 SQL로 확인할 수 있다.

```sql
SHOW PLUGINS;
```

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/Untitled%203.png)

---

## 4.1.5 컴포넌트

MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위한 **컴포넌트 아키텍처**를 지원

### 기존 플러그인 아키텍처의 단점

- 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신 불가
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

### 비밀번호 검증 기능 컴포넌트 사례

이러한 예시로 5.7 버전까지 **비밀번호 검증 기능**이 `플러그인 형태`로 제공됐지만
8.0 부터는 `컴포넌트`로 개선된 사례가 있다.

```sql
# validate_password 컴포넌트 설치
INSTALL COMPONENT 'file://component_validate_password';

# component 목록 조회
SELECT * FROM mysql.component;
```

![스크린샷 2024-08-11 21.18.56.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_21.18.56.png)

이렇게 설치만 하면 끝인 경우도 있지만
플러그인과 마찬가지로 컴포넌트도 설치하면서 새로운 시스템 변수를 설정해야할 수도 있으니,
사용 전에 메뉴얼을 살펴보자.

MySQL에서 기본으로 제공되는 컴포넌트에 대한 설명과 컴포넌트 개발에 대한 자세한 사항은 [메뉴얼](https://dev.mysql.com/doc/refman/8.0/en/server-components.html)을 참조하자

---

## 4.1.6 쿼리 실행 구조

![스크린샷 2024-08-11 21.23.01.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_21.23.01.png)

위 그림은 MySQL에서 쿼리 실행에 대한 구조를 간략히 표현한 것이다.
세부적으로 살펴보자.

### 4.1.6.1 쿼리 파서

사용자 요청으로 들어온 *쿼리문을 **토큰**(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리하여 **`트리` 형태의 구조**를 형성*

> 쿼리의 기본 문법 오류는 이 과정에서 발견되며 사용자에게 오류 메시지가 전달된다.
> 

### 4.1.6.2 전처리기

위 쿼리 파서에서 만들어진 **`파서 트리`** 를 기반으로 쿼리 문장에 *구조적 문제가 없는지 확인*

- 각 토큰을 테이블 이름, 칼럼 이름, 내장 함수와 같은 개체에 매핑하여
*해당 객체의 존재 여부, 객체 접근 권한 등을 확인*
- 실제 존재하지 않거나 권한이 없는 개체의 토큰은 이 단계에서 걸리짐

### 4.1.6.3 옵티마이저

사용자 요청으로 들어온 *쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할 방안(실행 계획)을 결정*하는 역할을 담당

- **`DBMS의 두뇌`** 에 해당된다.

> 이 책에서는 대부분 옵티마이저가 선택하는 내용을 설명할 것이며, 어떻게 하면 옵티마이저가 더 나은 선택을 할 수 있도록 유도하는가를 알려줄 것이다.
*그만큼 옵티마이저는 굉장히 중요하고 넓은 범위의 영향을 끼침*
> 

### 4.1.6.4 실행 엔진

옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.
(더 재밌는 비유로는 **옵티마이저** 는 ‘회사의 경영진’, **실행 엔진** 은 ‘중간 관리자’, **핸들러** 는 ‘각 업무의 실무자’로 비유)

실행엔진의 역할을 더 쉽게 이해할 수 있는 예제를 살펴보자

- 옵티마이저가 GROUP BY 를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 가정
    1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    2. 다시 실행 엔진은 WHERE절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청
    5. 최종 결과를 사용자나 다른 모듈로 넘김

> 즉 실행 엔진은 옵티마이저에서 만들어진 실행 계획대로 핸들러에게 요청을 보내서 결과를 받고
그 결과를 이용해 또 다른 핸들러에게 요청을 보내는 방식으로 역할을 수행하고
최종적으로 해당 결과를 다른 모듈 또는 사용자에게 넘긴다.
> 

### 4.1.6.5 핸들러(스토리지 엔진)

핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 아래 역할을 수행

- 데이터를 디스크로 저장
- 디스크로 부터 데이터 읽기

> **핸들러는 결국 스토리지 엔진을 의미** 하며
MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고 InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진이 된다.
> 

---

## 4.1.7 복제(Reflication)

MySQL 서버에서 복제는 매우 중요한 역할을 담당하며, 지금까지 많은 발전을 거듭해왔다.

자세한 내용은 별도의 장에서, 기본적인 복제의 아키텍처는 16장 ‘복제’에서 살펴보기로 하자.

---

## 4.1.8 쿼리 캐시

쿼리 캐시는 MySQL 8.0으로 올라오면서 MySQL 서버의 기능에서 완전히 제거되었으며,
관련된 시스템 변수도 모두 제거됐다.

### 쿼리 캐시란?

쿼리 캐시(Query Cache)는
SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하여 매우 빠른 성능을 제공해주는 기능이다.

때문에 빠른 응답을 필요로 하는 웹 기반 응용 프로그램에서 매우 중요한 역할을 담당했다.

### 단점

하지만 쿼리 캐시는 테이블의 데이터가 변경되면,
자연스럽게 변경이 발생한 테이블의 캐싱 데이터는 **모두 삭제** 되어야만 한다는 큰 단점이 있었다.

때문에 쿼리 캐싱은 테이블 데이터가 거의 변경되지 않고, 읽기 작업만 수행되는 테이블에서만 유용했고
그렇지 않은 경우 쿼리 캐싱은 오히려 **‘성능의 저하’**와 **‘수많은 버그의 원인’**이 되기만 했다.

실제 서비스에서 데이터가 거의 변경되지 않는 테이블이란 흔치 않았고,
이러한 이유 때문에 8.0 버전부터 완전히 삭제된 것이다.

---

## 4.1.9 스레드 풀

MySQL 서버 엔터프라이즈 에디션은 스레드 풀(Thread Pool) 기능을 제공하지만
커뮤니티 에디션은 스레드 풀 기능을 지원하지 않는다.

때문에 MySQL 엔터프라이즈 에디션에 포함된 스레드 풀 대신 **Percona Server**에서 제공하는 스레드 풀 기능을 살펴보고자 한다.

### **Percona Server**

엔터프라이즈 에디션에서 제공하며, MySQL 서버 프로그램에 내장되어있는 스레드 풀과 다르게
**Percona Server**의 스레드 풀은 *플러그인 형태로 작동하게 구현*되어 있다.

> MySQL 커뮤니티 버전에서 스레드 풀을 사용하려면, 동일 버전의 Percona Server에서 스레드 풀 플러그인 라이브러리(thread_pool.so 파일)를 MySQL 커뮤니티 에디션 서버에 설치(INSTALL PLUGIN 명령)해서 사용할 수 있다.
> 

### 스레드풀의 사용 목적

사용자 **요청을 처리하는 스레드 수를 줄여서** 동시 처리되는 요청이 많다하더라도,
MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서
`서버의 자원 소모를 줄이는 것` ****이 목적

> 즉 스레드 풀은,
동시에 실행 중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서
빨리 처리하게 하는 기능을 제공하는 것이 목적
> 

### 사용 시 주의점

많은 사람들이 스레드 풀을 설치만 하면 성능이 좋아지는 것을 기대한다.

하지만 스레드 풀이 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드물었다.

또한 앞에서 소개한 것처럼 동시에 실행 중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능이다.

- 때문에 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우,
쿼리 처리가 더 느려지는 사례도 발생할 수 있다.
    - 물론 제한된 수의 스레드만으로 CPU가 적절히 처리하도록 유도하면, CPU의 **프로세서 친화도(Processor affinity)** 도 높이고 운영체제 입장에서는 불필요한 **컨텍스트 스위치(Context switch)** 를 줄여서 오버헤드를 낮출 수 있다.

### CPU 프로세서 친화적인 스레드 풀 설정

**Percona Server** 의 스레드 풀은 기본적으로 **CPU 코어 수만큼** 스레드 그룹을 생성

- 이는 **‘thread_pool_size’** 시스템 변수를 변경해서 조정 가능

**‘thread_pool_size’** 는 일반적으로 CPU의 코어 수와 동일한 상태가 CPU 프로세서 친화도를 높이는 데 좋다.

### 스레드 풀에 스레드가 부족하면

MySQL 서버가 처리해야할 요청이 생기면 스레드 풀로 처리를 이관하는데,
만약 이미 스레드 풀이 처리중인 작업이 있는 경우에는 **‘thread_pool_oversubscribe’** 시스템 변수(기본 값은 3)에 설정된 개수만큼 추가로 더 받아들여서 처리한다.

때 **‘thread_pool_oversubscribe’** 의 값이 너무 크면 스케줄링해야 할 스레드 수가 많아져서 스레드 풀이 오히려 비효율적으로 작동할 수 있다.

스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은
**‘해당 스레드 그룹에 새로운 작업 스레드(Worker thread)를 추가할지’** 아니면 **‘기존 작업 스레드가 처리를 완료할 때까지 기다릴지’** 여부를 판단해야한다.

스레드 풀의 **‘타이머 스레드’**는 주기적으로 스레드 그룹의 상태를 체크해서 **‘thread_pool_stall_limit’** 시스템 변수에 정의된 밀리초(msec)만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 *새로운 스레드를 생성해서 스레드 그룹에 추가한다.*

> 즉, 모든 스레드 그룹의 스레드가 각자 작업을 처리하고 있는 상태에서
새로운 쿼리 요청이 들어오더라도 스레드 풀은 **‘thread_pool_stall_limit’** 시간동안 기다려야만 새로 들어온 요청을 처리할 수 있다는 뜻이다.

응답 시간에 아주 예민한 서비스라면, 해당 환경변수를 적절히 낮춰서 설정해야한다.
그렇다고 해서 0에 가까운 값으로 설정하는 것은 권하지 않는다.
0에 가까운 값으로 설정해야 한다면 스레드 풀을 사용하지 않는 편이 나을 것이다.
> 

이때 전체 스레드 풀에 스레드의 개수는 **‘thread_pool_max_threads’** 시스템 변수에 선언된 설정 개수를 넘기지 못한다.

### Percona Server 스레드 풀의 선순위 큐/후순위 큐

![스크린샷 2024-08-11 23.20.15.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_23.20.15.png)

Percona Server 스레드 풀의 경우 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다.

이렇게 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면
**해당 트랜잭션이 가지고 있던 락(Lock)도 빨리 해제**되며 **잠금 경합을 낮춰서 전체적인 처리 성능을 향상**시킨다.

<aside>
🚀 **[어떤 트랜잭션을 선순위에 배치한다고 잠금 경합이 낮춰지고 처리 성능이 올라가?]**

선순위 큐에 배치되는 트랜잭션은 보통 **다른 트랜잭션들에 영향을 많이 줄 수 있는 중요한 트랜잭션**이거나 **잠금을 오래 유지할 가능성이 있는 트랜잭션**이다.

트랜잭션이 시작된 순간, 해당되는 범위에 락을 걸기 때문에 광범위한 락이 걸린 트랜잭션이나 오래동안 유지되는 트랜잭션을 먼저 종료시키는 역할을 한다.

이렇게 중요한 트랜잭션을 먼저 처리함으로써, 그 트랜잭션이 보유한 잠금을 빨리 해제하고, 다른 트랜잭션들이 지연 없이 실행될 수 있도록 하는 것이다.

</aside>

---

## 4.1.10 트랜잭션 지원 메타데이터

데이터베이스 서버에서 **테이블의 구조** 정보와 **스토어드 프로그램** 등의 정보를 `데이터 딕셔너리` 또는 `메타데이터` 라고 한다.

MySQL5.7 버전까지는 테이블 구조를 FRM 파일에 저장하고, 일부 스토어드 프로그램 또한 파일 기반으로 관리했다.

하지만 *이러한 파일 기반 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않아서* 테이블 생성 또는 변경 도중 MySQL 서버가 비정상적으로 종료되면, 일관되지 않은 상태로 남는 문제가 있었다.

이를 사람들은 **”데이터베이스나 테이블이 깨졌다.”** 라고 표현했다.

MySQL8.0 버전부터는 이러한 문제 해결을 위해 **테이블 구조 정보**나 **스토어드 프로그램**의 코드 관련 정보를 모두 *InnoDB 테이블에 저장*하도록 개선됐다.

*’MySQL 서버가 작동하는데 기본적으로 필요한 테이블들’* 을 `시스템 테이블`이라고 일컫는데
대표적으로 사용자 인증과 권한 관련 테이블들이 있다.

MySQL 8.0은 이러한 `시스템 테이블`과 `메타데이터` 정보들을 모두 모아서 mysql DB에 저장하고 있다.
mysql DB는 통째로 mysql.ibd 라는 이름의 테이블스페이스에 저장된다.

때문에 서버의 데이터 딕셔너리에 존재하는 **mysql.ibd** 라는 파일은 다른 *.ibd 파일과 함께 특별히 주의해서 다뤄야한다.

<aside>
📃 mysql DB를 실제로 살펴보면 메타데이터 관련 정보를 가진 테이블을 찾을 수 없다.
이는 사용자가 임의로 메타데이터 테이블의 데이터를 함부로 수정하지 못하게 화면에 보여주지 않는 것이다.

대신 MySQL 서버는 **information_schema DB**의 `TABLES` 와 `COLUMNS` 등과 같은 뷰를 통해 조회할 수 있게 하고 있다.

**mysql** **DB**의 **tables** 테이블에 SELECT 쿼리를 실행해보면 ‘테이블이 없음’이 아니라 ‘접근이 거절됨’이라는 출력이 발생하는 것이 그 이유이다.

![스크린샷 2024-08-11 23.37.23.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_23.37.23.png)

</aside>

> 이를 통해 테이블 관련 작업도 트랜잭션 기반으로 동작하도록 하여,
스키마 변경 작업 도중 MySQL 서버가 종료된다고 해도 스키마 변경이 **완전 성공** 또는 **완전 실패** 로 정리된다.
> 

InnoDB가 아닌 다른 스토리지 엔진들은 여전히 메타데이터를 저장할 공간이 필요하기 때문에,
MySQL 서버가 제공하는 SDI(Serialized Dictionary Information) 파일을 사용한다.

- SDI는 기존의 FRM 파일과 동일한 역할을 한다.

### ibd2sdi

sdi는 이름의 뜻대로 직렬화를 위한 포맷이므로 ibd 파일도 sdi로 변경할 수 있다.

ibd2sdi 유틸리티를 사용하면 innoDB 테이블스페이스에서 스키마 정보를 추출할 수 있는데,
다음 예제는 mysql DB에 포함된 테이블의 스키마를 JSON 파일로 덤프한 것이다.

![스크린샷 2024-08-11 23.44.45.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-11_23.44.45.png)

---

# 4.2 InnoDB 스토리지 엔진 아키텍처

## 4.2.1 프라이머리 키에 의한 클러스터링

InnoDB는 데이터 레코드를 프라이머리 키에 따라 클러스터링하여 저장한다. 프라이머리 키의 값에 따라 데이터가 정렬되며, 데이터 페이지 내에서의 물리적 순서가 프라이머리 키의 순서와 일치한다. 이 방식은 데이터 조회 시 성능을 향상시킬 수 있으며, 인덱스 스캔 시 효율적인 데이터 접근을 가능하게 한다.

## 4.2.2 외래 키 지원

InnoDB는 외래 키 제약 조건을 지원하여 데이터 무결성을 유지한다.

외래 키를 사용하면 다른 테이블의 레코드와의 관계를 정의하고, 부모 테이블에서 삭제되거나 업데이트된 데이터에 따라 자식 테이블의 데이터도 자동으로 업데이트하거나 삭제할 수 있다.(cascade) 이는 데이터베이스의 일관성을 보장하는 중요한 기능이다.

## 4.2.3 MVCC(Multi Version Concurrenct Contorl)

MVCC는 InnoDB의 동시성 제어 기법으로, 트랜잭션이 데이터의 여러 버전을 유지하여 다른 트랜잭션의 작업에 영향을 받지 않도록 한다. 각 트랜잭션이 시작된 시점의 데이터 스냅샷을 제공하여 읽기 작업이 쓰기 작업과 충돌하지 않도록 하며, 데이터의 일관성을 유지하는 데 도움을 준다.

## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB는 MVCC를 사용하여 잠금 없이 일관된 읽기를 제공한다. 이는 트랜잭션이 시작될 때의 데이터 상태를 기준으로 읽기를 수행하여 다른 트랜잭션의 변경 사항에 영향을 받지 않게 한다. 이를 통해 데이터 일관성을 유지하면서도 동시성 높은 작업을 가능하게 한다.

## 4.2.5 자동 데드락 감지

InnoDB는 자동으로 데드락을 감지하고 해결하는 기능을 제공한다. 데드락이 발생하면 InnoDB는 트랜잭션 중 하나를 롤백하여 데드락 상태를 해소하고, 다른 트랜잭션들이 정상적으로 실행될 수 있도록 한다. 이 과정은 시스템의 안정성을 유지하는 데 중요하다.

## 4.2.6 자동화된 장애 복구

InnoDB는 자동으로 장애를 감지하고 복구하는 기능을 제공한다.

장애 발생 시 리두 로그를 사용하여 트랜잭션을 복구하고 데이터베이스의 무결성을 보장한다. 이 기능은 데이터 손실을 최소화하고 시스템의 신뢰성을 높인다.

## 4.2.7 InnoDB 버퍼 풀

InnoDB 버퍼 풀은 디스크 I/O를 줄이기 위해 메모리에 데이터와 인덱스 페이지를 캐시한다.

버퍼 풀은 자주 액세스되는 데이터를 메모리에 유지하여 성능을 향상시키며, 데이터베이스의 읽기 및 쓰기 작업의 효율성을 높인다.

## 4.2.8 Double Write Buffer

Double Write Buffer는 데이터를 디스크에 쓰기 전에 두 번 쓰는 방식으로, 데이터의 무결성을 보호한다. 이 버퍼는 데이터 페이지를 디스크에 안전하게 기록하고, 디스크의 오류로부터 데이터를 보호하여 데이터 손상을 방지한다.

## 4.2.9 언두 로그

언두 로그는 트랜잭션의 변경 사항을 취소할 수 있도록 이전 상태를 기록하는 로그이다.

트랜잭션이 롤백될 때 언두 로그를 사용해 데이터의 원래 상태로 복구할 수 있으며, 트랜잭션의 일관성을 보장하는 중요한 역할을 한다.

- **언두 로그 (Undo Log)**: 트랜잭션의 변경 사항을 취소하거나 롤백할 수 있도록 이전 상태를 기록하는 로그이다. 트랜잭션이 롤백될 때 이 로그를 사용하여 데이터의 원래 상태로 되돌릴 수 있다. 즉, 트랜잭션이 실패하거나 롤백될 때, 언두 로그를 통해 변경 사항을 되돌리며 데이터의 일관성을 유지한다.
- **언두 로그**는 트랜잭션이 롤백될 때 데이터의 원래 상태로 되돌리기 위해 사용된다.

## 4.2.10 체인지 버퍼

체인지 버퍼는 디스크에 직접 기록하기 전에 변경된 데이터의 정보를 메모리에 저장하는 버퍼이다.

주로 비클러스터 인덱스의 변경 사항을 처리하며, 디스크 I/O를 줄이고 성능을 향상시킨다.

## 4.2.11 리두 로그 및 로그 버퍼

리두 로그는 데이터베이스의 변경 사항을 기록하여 장애 발생 시 복구에 사용된다.

로그 버퍼는 리두 로그를 메모리에 임시 저장하여 디스크 I/O를 최소화하고 성능을 개선하는 데 도움을 준다.

- **리두 로그 (Redo Log)**: 데이터베이스의 데이터 변경 사항을 기록하여 시스템 장애 발생 시 데이터의 복구를 지원한다. 리두 로그는 트랜잭션의 커밋된 변경 사항을 기록하며, 장애가 발생했을 때 이 로그를 사용해 데이터를 복구할 수 있다. 즉, 커밋된 트랜잭션의 변경 사항을 다시 적용하는 데 사용된다.
- **리두 로그**는 커밋된 변경 사항을 복구하기 위해 사용되고,

## 4.2.12 어댑티브 해시 인덱스

어댑티브 해시 인덱스는 자주 조회되는 데이터에 대해 해시 인덱스를 동적으로 생성하여 검색 성능을 높인다. 데이터에 대한 액세스 패턴을 분석하여 해시 인덱스를 생성하고, 검색 속도를 향상시킨다.

## 4.2.13 InnoDB와 MyISAM, MEMORY 스토리 엔진 비교

- **InnoDB**: 트랜잭션을 지원하며 ACID 특성을 보장하고, 행 수준 잠금과 MVCC를 제공한다. 데이터 무결성과 동시성 처리에서 우수하다.
- **MyISAM**: 트랜잭션을 지원하지 않지만 읽기 성능이 뛰어나며, 테이블 수준의 잠금을 사용한다. 데이터 무결성 보장 측면에서는 한계가 있지만, 간단한 구조로 읽기 작업이 빠르다.
- **MEMORY**: 데이터를 메모리에 저장하여 빠른 읽기/쓰기 성능을 제공하지만, 서버 재시작 시 데이터가 사라진다. 테이블 수준의 잠금을 사용하며, 주로 임시 데이터 저장에 적합하다.

---

# 4.3 MyISAM 스토리지 엔진 아키텍처

MyISAM 스토리지 엔진의 성능에 영향을 미치는 요소인 키 캐시와 운영체제의 캐시/버퍼에 대해 살펴본다.

![스크린샷 2024-08-12 02.15.17.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_02.15.17.png)

## 4.3.1 키 캐시

InnoDB의 버퍼 풀과 비슷한 역할 수행

- 이름 그대로 키 캐시는 *인덱스만을 대상으로 작동*
- 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할

### 키 캐시의 히트율

<aside>
📃 **[키 캐시 히트율 계산]**
100 - (Key_reads / Key_read_requests * 100)

</aside>

- `Key_reads`: 인덱스를 디스크에서 읽어들인 횟수 저장 상태 변수
- `Key_read_requests`: 키 캐시로부터 인덱스를 읽은 횟수 저장 상태 변수

```sql
# 위의 값 확인
SHOW GLOBAL STATUS LIKE 'Key%'
```

![스크린샷 2024-08-12 02.19.52.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_02.19.52.png)

### 권장 캐시 히트율 99%

메뉴얼에서는 일반적으로 키 캐시의 히트율을 99% 이상으로 유지하라고 권장한다.
해당 값에 미치지 못한다면 키 캐시를 조금 더 크게 설정하는 것이 좋다.

> 기본 키 캐시 공간 설정 파라미터인 **‘key_buffer_size’** 를 통해 캐시 메모리 공간 설정이 가능하다.
> 

---

## 4.3.2 운영체제의 캐시 및 버퍼

MyISAM의 인덱스는 키 캐시를 이용해 디스크 검색 없이 충분히 빠르게 검할 수 있다.

하지만 테이블의 데이터에 대해서는 디스크 I/O에 대한 어떠한 캐시나 버퍼링 기능도 가지고 있지 않기 때문에 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청된다.

때문에 매번 디스크 I/O를 수행하지는 않는다.

- 운영체제는 InnoDB처럼 데이터의 특성을 알고 전문적으로 캐시나 버퍼링을 하지 못하지만 없는 것 보다 훨씬 낫다.

---

## 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

InnoDB 를 사용하는 테이블은 프라이머리 키에 의해서 클러스터링되어 저장되는 반면,
MyISAM은 테이블의 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용된다.

- 즉 테이블의 레코드가 프라이머리 키 값과 무관하게 INSERT 되는 순서대로 데이터 파일에 저장
- 테이블에 저장되는 레코드는 모두 `ROWID` 라는 물리적 주소값을 갖는다.
    - 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 `ROWID` 값을 포인터로 가짐
    - ROWID 종류
        - 고정 길이 ROWID
        - 가변 길이 ROWID

---

# 4.4 MySQL 로그 파일

**로그 파일:** MySQL 서버의 깊은 내부 지식이 없어도 MySQL의 상태나 부하의 원인을 쉽게 찾아서 해결하게 해준다.

많은 사용자가 로그 파일의 내용을 무시하고 다른 방법으로 해결책을 찾으려고 노력하는데,
무엇보다 **MySQL 서버의 문제가 발생하면** 다음에 설명하는 로그파일들을 자세히 확인하는 습관을 들일 필요가 있다.

## 4.4.1 에러 로그 파일

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그파일

- `파일 위치`: MySQL 설정파일(my.cnf)에서 **log_error** 라는 이름의 파라미터로 정의된 경로에 생성
    - 해당 경로에 정의되지 않은 경우, 데이터 디렉터리(datadir 파라미터에 설정된 디렉터리)에 **.err** 라는 확장자가 붙은 파일로 생성

## 4.4.1.1 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지

MySQL의 설정파일을 변경하거나 데이터베이스가 비정상적으로 종료된 후 다시 시작하는 경우 반드시 에러 로그 파일을 통해 설정이 의도대로 적용되었는지 확인해야 한다.

**서버 정상 가동 메시지(mysqld: ready for connection)** 가 정상적으로 확인되며, 변경 사항에 대한 특별한 에러나 경고성 메시지가 없다면 정상처리 된 것이다.

만약 그렇지 않고 특정 변경이 **무시(ignore)** 된 경우라면 서버는 정상 가동하지만 설정이 적용되지 못했음을 의미한다.
*이는 에러 로그를 통해 확인할 수 있을 것이다.*

## 4.4.1.2 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB 트랜잭션 복구 메시지

만약 비정상적으로 서버가 종료되었다면, 다시 시작되면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 한다.

- 이때 `리두 로그` 사용

이 과정에서 간단한 메시지가 출력되는데, 간혹 문제가 있어서 복구에 실패한 경우 에러 메시지를 출력하고 MySQL은 다시 종료된다.

일반적으로 이 단계에서 발생하는 문제는 상대적으로 해결이 어려운 문제점일 경우가 많고,
때로는 **’innodb_force_recovery’** 파라미터를 `0보다 큰 값` 으로 설정하고 재시작해야만 MySQL이 시작될 수 있다.

- **’innodb_force_recovery’** 에 대한 자세한 내용은 4.2.6절을 참조하자

## 4.4.1.3 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지

실행 도중 발생한 쿼리 중, 문제가 될만한 쿼리에 대해서 기록되는 에러 메시지.

쿼리 도중 발생하는 문제점은 사전 예방이 어려우며, 주기적으로 로그 파일을 검토하는 과정에서 알게 된다.

- 그래서 *에러 로그를 자주 검토하는 것*이 데이터베이스의 숨겨진 문제점을 해결하는 데에 많은 도움을 준다.

## 4.4.1.4 비정상적으로 종료된 커넥션 메시지(Aborted connection)

*클라이언트 애플리케이션에서 정상적으로 접속 종료를 못하고 프로그램이 종료된 경우* 에러 로그에 기록되는 메시지다.

어떤 데이터베이스 서버의 로그 파일에는 이 메시지가 상당히 많이 누적되어 있는 경우가 있다.

- 이 메시지가 자주 기록된다면 애플리케이션의 커넥션 종료 로직을 검토해볼 필요가 있다.

**‘max_connection_errors’** 시스템 변수값이 너무 낮게 설정된 경우
클라이언트 프로그램이 MySQL 서버에 접속하지 못하고 **“Host ‘host_name’ is blocked”** 라는 에러를 발생할 수도 있다.

이 메시지는 클라이언트 호스트에서 발생한 에러(커넥션 실패나 강제 연결 종료 등)의 횟수가 max_connect_errors 변수의 값을 넘게 되면 발생하는데
max_connect_errors의 값을 증가시켜 해결할 수 있다.

- max_connect_errors 값 증가 이전에 해당 에러가 발생한 원인을 먼저 살펴보는 것이 좋다.

## 4.4.1.5 InnoDB 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은)의 결과 메시지

InnoDB의 테이블 모니터링이나 락 모니터링 또는 InnoDB 엔진 상태 조회 명령에서 발생하는 메시지

해당 명령은 큰 메시지를 에러 로그 파일에 기록한다.
InnoDB 모니터링을 활성화 상태로 만들어두고 그대로 유지하는 것은 에러 로그 파일을 문제가 발생할 정도로 매우 크게 만들어버린다.

이 때문에 항상 모니터링 사용 이후에는 다시 비활성화 해두어야 한다.

## 4.4.1.6 MySQL의 종료 메시지

MySQL이 아무도 모르게 종료되거나 재시작되는 경우 발생하는 메시지

에러 로그 파일에서 MySQL이 갑자기 왜 종료되었는지 확인하는 것이
왜 종료되었는지 알 수 있는 유일한 방법이다.

---

## 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)

MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아서 검토해볼 때가 있는데, 이때 사용되는 것이 제너럴 로그이다.

- 쿼리 로그를 활성화해서 쿼리를 쿼리 로그파일로 기록하게 한 다음 그 파일을 검토하는 방식으로 사용
- 시간 단위로 실행됐던 쿼리 내용이 모두 기록
- 정상적으로 작동된 쿼리만 기록하는 슬로우 쿼리 로그와는 다르게
제너럴 쿼리 로그는 MySQL이 쿼리 요청을 받으면 바로 기록하기 때문에 *에러가 발생한 쿼리도 일단 로그파일에 기록*된다.

### 제너럴 로그 파일의 경로

**‘general_log_file’** 이라는 이름의 파라미터에 로그 파일의 경로가 설정되어있다.

- 슬로우 쿼리와 마찬가지로 쿼리 로그를 파일이 아닌 테이블에 저장하도록 설정 가능
    - 쿼리 로그를 파일로 저장할지 테이블로 저장할지는 **‘log_output’** 파라미터로 결정된다.
        - 자세한 내용은 MySQL 메뉴얼의 **‘log_output 설정 파라미터’** 참조

```sql
SHOW GLOBAL VARIABLES LIKE 'general_log_file';
```

![스크린샷 2024-08-12 02.13.00.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_02.13.00.png)

---

## 4.4.3 슬로우 쿼리 로그

서비스 운영 중에 MySQL 서버의 전체적인 성능저하를 감시하거나, 정기적인 점검을 위한 튜닝의 경우
슬로우 쿼리 로그가 상당히 많은 도움이 된다.

### 슬로우 쿼리 판단

**‘long_query_time’** 시스템 변수에 설정한 시간(초단위, 소숫점으로 입력하면 마이크로 초 단위도 설정 가능) 이상의 시간이 소요되었으며,
정상적으로 실행된 쿼리를 슬로우 쿼리로 취급한다.

### 파일 기록 VS 테이블 기록

log_output 옵션을 이용해서 슬로우 쿼리 로그를 테이블로 기록할지 로그 파일로 기록할 지 설정 가능

- 옵션을 `TABLE`로 설정
    - mysql DB의 general_log, slow_log 테이블에 저장
    - 테이블에 저장하더라도 CSV 스토리지 엔진을 사용하기 때문에 결국 CSV 파일로 저장하는 것과 동일하게 작동
- 옵션을 `FILE`로 설정
    - 디스크의 파일로 저장

### 락(Lock)으로 인한 시간 차이

InnoDB는 MyISAM이나 MEMORY와는 다르게 락을 수행한다.

이러한 이유로 슬로우 로그 쿼리에 출력되는 내용은 조금 혼란스러울 수 있다.

![스크린샷 2024-08-12 01.42.18.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_01.42.18.png)

- `Time`
    - 쿼리가 종료된 시점을 의미
    - 쿼리의 시작 시간을 구하려면 ‘Time - Query_time’
- `User@Host`
    - 쿼리를 실행한 사용자의 계정
- `Query_time`
    - 쿼리가 실행되는데 걸린 시간
    - `Lock_time`
        - MySQL 엔진 레벨에서 관장하는 테이블 잠금에 대한 대기 시간만 표현
        - 0이 아니라고 해서 무조건 락이 풀리기를 기다렸다는 의미가 아니다.
            - 잠금 대기 시간뿐만 아니라, 잠금 체크와 같은 코드 실행부의 시간까지 포함되기 때문
            - 매우 작은 값이면 무시해도 된다.
- `Row_examined`
    - 이 쿼리가 처리되기 위해 몇 건의 레코드에 접근되었는지를 의미
    - `Row_sent`
        - 실제 몇 건의 처리 결과를 클라이언트로 보냈는지 의미
    - Row_examined는 높지만, Row_sent의 수가 상당히 적다면 이 쿼리는 더 적은 레코드만 접근하도록 튜닝해볼 가치가 있음을 뜻함
        - GROUP BY, COUNT(), MIN(), MAX() 등과 같은 집함함수가 아닌 쿼리의 경우에만 해당되는 얘기

### MyISAM, MEMORY 와의 차이

MyISAM, MEMORY 스토리지 엔진은 테이블 단위의 락을 사용하고 MVCC와 같은 매커니즘이 없어서 SELECT 쿼리라고 하더라도 Lock_time이 1초 이상 소요될 가능성이 높다.

InnoDB도 해당 엔진의 레코드 수준의 잠금이 아닌 *MySQL 엔진 레벨에서 설정한 테이블 잠금에 의해* 상대적으로 큰 값이 발생할 수도 있다.

- 때문에 InnoDB *테이블에만 접근하는 쿼리 문장의 슬로우 쿼리 로그*는 Lock_time값은 튜닝에 별 도움이 되지 않는다.

### Percona Toolkit - pt-query-digest

일반적으로 로그 상의 쿼리의 양이 상당히 많아서 직접 쿼리를 하나하나 검토하기에는 시간이 많이 걸리거나, 집중적으로 튜닝할 쿼리를 식별하기 어렵다.

이때 도움을 주는 것이 Percona Toolkit의 **pt-query-digest** 이다.

- 이를 통해 빈도나 처리 성능 별로 쿼리를 정렬해서 볼 수 있음.

```bash
# General Log 파일 분석
pt-query-digest --type='genlog' general.log > parsed_general.log
```

```bash
# Slow Log 파일 분석
pt-query-digest --type='slowlog' mysql-slow.log > parsed_mysql-slow.log
```

파일이 분석되면 그 결과는 3개의 그룹으로 나뉘어 저장된다.

## 4.4.3.1 슬로우 쿼리 통계

![스크린샷 2024-08-12 01.59.42.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_01.59.42.png)

분석 결과의 최상단에 표시되며 아래 정보를 표시한다.

- `Exec time`: 슬로우 쿼리 로그의 실행 시간
- 잠금 대기 시간(Lock time) 등에 대해 평균 및 최소/최대 값

## 4.4.3.2 실행 빈도 및 누적 실핼 시간순 랭킹

![스크린샷 2024-08-12 02.01.29.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_02.01.29.png)

각 쿼리별로 응답 시간과 실행 횟수를 보여주는데
**pt-query-digest** 명령 실행시 `—order-by` 옵션으로 정렬 순서를 변경할수있다.

Query ID는 실행된 쿼리 문장을 정규화(쿼리에 사용된 리터럴을 제거)해서 만들어진 해시값을 의미하는데, 일반적으로 같은 모양의 쿼리라면 동일한 QueryID를가지게된다.

## 4.4.3.2 실행 빈도 및 누적 실행 시간순 랭킹

Query ID 별로 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여준다.

랭킹별 쿼리에서는 대상 테이블에 대해 어떤 쿼리인지만을 표시하는데,
실제 상세한 쿼리 내용은 개별 쿼리의 정보를 확인해보면 된다.

여기서는 쿼리가 얼마나 실행됐는지, 쿼리의 응답 시간에 대한 히스토그램 같은 상세 내용을 보여준다.

![스크린샷 2024-08-12 02.01.41.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20843c2503c7564b76af13b1cf79169b4c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-12_02.01.41.png)