# 08. 인덱스

- 인덱스에 대한 기본 지식은 지금도 앞으로도 개발자나 관리자에게 매우 중요한 부분이며, 쿼리 튜닝의 기본이 될 것이다.

## 8.1 디스크 읽기 방식

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- CPU나 메모리는 대부분 전자식 장치이지만, HDD는 기계식 장치이다.
  - DB 서버에서는 항상 디스크 장치가 병목이 된다.
- 기계식 HDD를 대체하기 위해 전자식 저장 매체인 SSD가 많이 출시되고 있다.
  - 기존 HDD와 같은 인터페이스(SATA or SAS)를 지원하므로 내장 디스크나 DAS 또는 SAN에 그대로 사용할 수 있다.

- SSD
  - SSD는 데이터 저장용 플래터(원판) 대신 플레시 메모리를 장착하고 있어, 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.
  - 플레시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않는다.
  - 순차 I/O는 HDD와 비슷한 성능을 보이나, 랜덤 I/O는 훨씬 빠르다
  - 요즘은 DBMS용으로 사용할 서버에는 대부분 SSD를 채택하고 있다.

### 랜덤 I/O와 순차 I/O

- 랜덤 I/O와 순차 I/O (HDD)
  - 3개의 페이지를 디스크에 기록할 때, 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 한 번 움직이고, 랜덤 I/O는 디스크 헤드를 3번 움직인다. (약 3배 정도 느림)
  - 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.
- 랜덤 I/O와 순차 I/O (SSD)
  - 랜덤 I/O는 순차 I/O보다 전체 스루풋(Throughput)이 떨어진다.
  - 그래서 SSD 사양에도 항상 순차 I/O와 랜덤 I/O의 성능 비교를 구분해서 명시한다.

- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
  - 랜덤 I/O를 줄인다 == 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것

## 8.2 인덱스란?

- DB의 특정 테이블의 모든 데이터를 칼럼(들)의 값과 해당 레코드의 저장된 주소를 Key - Value 페어로 가지고 있어, Key 값에 따라 정렬한 구조
  - 데이터가 저장될 때(`INSERT`, `UPDATE`, `DELETE`)는 항상 정렬해야 하므로 느리지만, 데이터를 불러올 때(`SELECT`)는 정렬되어 있으므로 빠르게 찾을 수 있다.
- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.

- Primary Key vs Secondary Key
  - Primary Key : 그 레코드를 대표하는 컬럼으로 만들어진 인덱스
  - Secondary Key : 프라이머리 키를 제외한 나머지 모든 인덱스
- B-Tree 알고리즘 vs Hash 인덱스 알고리즘
  - B-Tree 알고리즘 : 가장 일반적으로 사용되는 알고리즘, 칼럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘 (응용. R-Tree 알고리즘)
  - Hash 인덱스 알고리즘 : 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색 지원, 범위 탐색에는 지원 불가
- Unique 인덱스 vs Non-Unique 인덱스
  - 데이터 중복 허용 여부에 따라 다르다
  - 유니크 인덱스에 대해 동등 조건으로 검색된다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
  - 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점이 상당히 많다.
- cf) 전문 검색용 인덱스, 공간 검색용 인덱스, ...

## 8.3 B-Tree (Balanced-Tree) 인덱스

- DB의 인덱싱 알고리즘 중에 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘

### 구조 및 특성

- 트리 구조 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
  - 루트 노드 - 브랜치 노드 - 리프 노드로 구성
  - 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

- 파일의 레코드는 `INSERT`를 수행한 순서대로 저장하지 않는다.
  - 레코드가 삭제되어 빈 공간이 생기면 그 다음의 `INSERT`는 가능한 삭제된 공간을 재활용하도록 설계되어 있다.

- InnoDB 스토리지 엔진에서는 세컨더리 인덱스의 리프 노드가 PK값을 가지고 있다.
  - 해당 PK값을 이용해 PK 인덱스를 한 번 더 검색한 후, PK 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.

### B-Tree 인덱스 키 추가 및 삭제

- 인덱스 키 추가
  - 적절한 위치를 검색하여 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
  - 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
  - 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.
- 인덱스 키 존재 시, 로우 추가 비용
  - 테이블의 칼럼 수, 칼럼의 크기, 인덱스 컬럼의 특성에 따라 비용이 다르다
  - 대략적으로 테이블에 레코드를 추가하는 비용이 1이라면, 해당 테이블의 인덱스에 키를 추가하는 작업은 1.5이다.
  - 중요한 것은 이 대부분이 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이라는 점이다.
- InnoDB 스토리지 엔진에서의 인덱스 키 추가
  - 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리한다.
  - PK나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.
  - 자세한 사항은 4.2.10절 '체인지 퍼버'를 참조

- 인덱스 키 삭제
  - 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 작업이 완료된다.
  - 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다. (디스크 I/O가 필요)
    - MySQL 5.5 이상의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수 있다.

- 인덱스 키 변경
  - B-Tree의 키 값이 변경되는 경우에는 위치가 변경되어야 하므로, 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
  - InnoDB 스토리지 엔진을 사용하는 테이블에서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다.

- 인덱스 키 검색
  - 트리 탐색 : 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행
  - `SELECT`는 물론, `UPDATE`, `DELETE`를 처리하기 위해 레코드를 먼저 검색해야 할 때도 사용
  - B-Tree를 인덱스를 이용한 검색은 100% 일치, 앞부분 일치, 부등호 비교 에서 사용 가능
    - 뒷부분만 검색하는 용도, 변경이 가해진 후 비교(ex. 함수, 연산)로는 사용 불가
- InnoDB 스토리지 엔진에서 인덱스 키 검색
  - InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있음
  - `UPDATE`, `DELETE` 문장이 실행될 때, 테이블에 적절히 사용될 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스 키 값의 크기
  - 최대한 작게 만드는 것이 좋다 (한 페이지에 가질 수 있는 row와 연관)
- B-Tree 깊이
  - MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 값을 읽어야 하는 지와 직결된다
  - 아무리 큰 DB라고 해도, B-Tree 깊이가 6을 넘어가지 않는다.
- 선택도 (기수성) : 모든 인덱스 키 값 가운데 유니크한 값의 수
  - 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다.
  - 인덱스나 쿼리의 효율성에 큰 영향을 미침
- 읽어야 하는 레코드의 건 수
  - 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드를 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업이라고 예측한다.
  - 인덱스를 통해 읽어야 할 레코드 건 수가 전체 테이블 레코드의 20~25%를 넘어서면 모두 읽어서 필터링 방식으로 처리하는 것이 효율적이다.

### B-Tree 인덱스를 통한 데이터 읽기 방법

- 인덱스 레인지 스캔
  - 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
    - 1단계. 인덱스 탐색 : 인덱스에서 조건을 만족하는 값을 찾는다
    - 2단계. 인덱스 스캔 : 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다
    - 3단계. 읽어 드린 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
  - 상대적으로 아래 방법들보다 빠름

- 인덱스 풀 스캔
  - 인덱스의 처음부터 끝까지 모두 읽는 방식
    - ex) 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우
  - 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우
    - 인덱스의 전체 크기는 테이블 자체 크기보다는 훨씬 작으므로 테이블 전체를 읽는 것보다는 적은 디스크 I/O로 처리 가능하다.

- 루스(Loose) 인덱스 스캔
  - '인덱스 스킵 스캔'과 작동 방식은 비슷하지만, MySQL에서는 이를 '루스 인덱스 스캔'이라 부른다.
  - '인덱스 레인지 스캔'에서 중간에 필요치 않은 인덱스 키 값을 무시하고 다음으로 넘어가는 형태
- 인덱스 스킵 스캔
  - MySQL 8.0부터 '다중 컬럼 인덱스'에서도 스킵을 할 수 있도록 최적화가 되었다.
  - MySQL 8.0에서 인덱스 스킵 스캔의 단점
    - `WHERE` 조건 절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
    - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

### 다중 컬럼 인덱스

- 두 개 이상의 칼럼으로 구성된 인덱스
- 먼저 첫 번째 칼럼을 기준으로 정렬 후, 첫 번째 칼럼이 같은 경우 두 번째 칼럼 기준으로 정렬함
  - 다중 칼람 인덱스에서는 인덱스 내에서 각 칼럼의 위치가 상당히 중요하며, 아주 신중히 결정해야 한다.

### B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.

- 인덱스의 정렬
  - MySQL 8.0부터는 정렬 순서를 혼합한 인덱스를 생성할 수 있다.
  ```mysql
  CREATE INDEX ix_name_score ON players (name ASC, score DESC);
    ```
  - 쿼리가 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.
- 읽는 방향에 따른 속도 차이 : 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다.
  - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이다.
  - 페이지 내에서는 인덱스 레코드가 단방향으로만 연결된 구조이다.
- 앞쪽 혹은 뒤쪽 부분만 집중적으로 실행된다면, 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다.

### B-Tree 인덱스의 가용성과 효율성

- 비교 조건의 종류와 효율성
  - 작업 범위 결정 조건이 많으면 많을수록 쿼리의 처리 성능을 높이지만, 체크 조건이 많아지면 오히려 느리게 만들 수 있다.
- 인덱스의 가용성
  - `LIKE '%mer'`과 같이 왼쪽으로 정렬하여 구할 수 없는 경우에는 인덱스를 사용히는 것이 비효율적이다.

- 인덱스를 사용할 수 없는 경우 (경우에 따라서 체크 조건으로 사용)
  - NOT-EQUAL로 비교된 경우
  - LIKE '%??'
  - 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
  - NOT-DETERMINSTIC 속성의 스토어드 함수가 비교 조건으로 사용된 경우
  - 데이터 타입이 서로 다른 비교 (15장 참조)
  - 문자열 데이터 타입의 콜레이션이 다른 경우 (15.1.4절 참조)

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우 ex) INDEX ix_test (column_1, ...)
  - column_1 칼럼에 대한 조건이 없는 경우
  - column_1 칼럼의 비교 조건이 '인덱스를 사용할 수 없는 경우'
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우
  - column_1 ~ column(i-1) 칼럼까지 동등 비교 형태로 비교
  - column_i 컬럼에 대해 동등 비교, 크기 비교 또는 `LIKE '??%'`

## 8.4 R-Tree 인덱스

- 공간 인덱스 (Spatial Index)
  - R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
- MySQL의 공간 확장 기능
  - 공간 데이터를 저장할 수 있는 타입
  - 공간 데이터의 검색을 위한 공간 인덱스 (R-Tree)
  - 공간 데이터의 연산 함수 (거리 또는 포함 관계의 처리)

### 구조 및 특성
- MySQL 공간을 위한 지원 타입 : `POINT`, `LINE`, `POLYGON`
- MBR(Minimum Bounding Rectangle) : 해당 도형을 감싸는 최소 크기의 사각형
- R-Tree : 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스
  - 하위 노드에는 상위 노드의 포함된 도형들이 있다.

### R-Tree 인덱스의 용도
- 일반적으로 위도,경도 좌표 저장에 주로 사용
  - CAD/CAM 소프트웨어 또는 회로 디자인과 같이 좌표 시스템이 기반을 준 정보에 대해서는 모두 적용 가능
- R-Tree 인덱스 사용
  - `ST_Contains()`, `ST_Within()` 등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스 사용 가능
  - 현재 출시되는 MySQL에서는 `ST_Distance()`, `ST_Distance_Sphere()` 함수는 공간 인덱스를 효율적으로 사용하지 못함
- 참고
  - `ST_Contains()`, `ST_Within()`는 MBR로 비교하기 때문에 사각형 단위로 검색을 한다.
    - 반경 5km 내 특정 위치들을 검색한다면, 가로 세로 5km인 사각형으로 검색
  - 원 단위로 검색하면서, 인덱스를 사용하고 싶다면 필터링을 이용할 것
    ```mysql
    SELECT * FROM Location
    WHERE ST_Contains(사각상자, px)
    AND ST_Distance_Sphere(p, px) <= 5*1000
        ```

## 8.5 검색 전문 인덱스

- 전문 검색 인덱스 (Full Text Search Index) : 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘

### 인덱스 알고리즘

- 전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해내고, 빠른 검색용으로 사용할 수 있게 키워드로 인덱스를 구축한다.
- 전문 검색 인덱스는 문서의 키워드를 인덱싱하는 방법에 따라 나눌 수 있다.

- 불용어 처리
  - 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
  - MySQL 서버는 사용자가 별도로 불요어를 정의할 수 있는 기능 제공
- 어근 분석 알고리즘
  - 어근 분석 : 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
  - 언어 마다 분석 라이브러리가 다르지만, 한국어는 일본어와 많이 비슷하기 때문에 MeCab을 플러그인 형태로 사용할 수 있도록 함 (한글에 맞게 완성도를 갖추는 작업은 많은 시간과 노력 필요)
- n-gram 알고리즘
  - 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘
  - 본문을 무조건 몇 글자씩 잘라 인덱싱하는 방법
  - 2-gram의 경우, 2글짜식 중첩해서 토큰으로 분리 후, 불용어(일치하는 경우, 포함되는 경우)를 제거한 후에 각 토큰을 인덱스에 저장한다.
- 불용어 변경 및 삭제
  - 기본 설정된 불용어(ex. 'a', 'i')는 더 혼란스럽게 할 수 있기 때문에 불용어를 무시하거나 직접 등록하기를 권장함
  - MySQL 서버의 불용어 처리 무시/설정 방법 : `ft_stopword_file=''('data/my_stopword.txt')`으로 설정한 후에 재시작
  - InnoDB 스토리지 엔진 테이블에서 불용어 무시 방법 : `innodb_ft_enable_stopword=OFF`
  - InnoDB 스토리지 엔진 테이블에서 불용어 설정 방법
    ```sql
    SET GLOBAL innodb_ft_server_stopword_table='mydb/my_stopworld'
    ALTER TABLE tb_bi_gram
        ADD FULLTEXT INDEX fx_title_body(title, body) WITH PARSER ngram;
        ```

### 전문 검색 인덱스의 가용성

- 전문 검색 인덱스를 사용하기 위한 두 가지 조건
  - 쿼리 문장이 전문 검색을 위한 문법을 사용 (ex. `MATCH` ~ `AGAINST` ~)
  - 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유
  - ex
    ```sql
    SELECT * FROM tb_text
    WHERE MATCH (doc_body) AGAINST ('apple' IN BOOLEAN MODE)
        ```

## 8.6 함수 기반 인덱스

### 가상 컬럼을 이용한 인덱스

- MySQL 8.0부터 가상 컬럼을 추가하고 가상 컬럼에 인덱스를 사용할 수 있다
  ```sql
   ALTER TABLE
     ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
     ADD INDEX ix_fullname (full_name);
  ```
  - 가상 컬럼이 `VIRTUAL`, `STORED` 옵션 상관없이 가상 컬럼의 인덱스 생성할 수 있다 (참조 15.8절)

### 함수를 이용한 인덱스

- MySQL 8.0부터는 테이블 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있다.
  ```sql
  CREATE TABLE member (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id),
    INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))
  );
    ```

## 8.7 멀티 밸류 인덱스

- 멀티 밸류 인덱스 : 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 인덱스
  - 최근 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건 발생
- 멀티 밸류 인덱스를 활용하기 위해서는 반드시 아래와 같은 함수를 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.
  - `MEMBER_OF()`, `JSON_CONTAINS()`, `JSON_OVERLAPS()`

## 8.8 클러스터링 인덱스

- MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(PK)들끼리 묶어서 저장하는 형태로 구현
- InnoDB 스토리지 엔진에서만 클러스터링 인덱스를 지원함

### 클러스터링 인덱스

- 테이블의 PK에 대해서만 적용되는 내용
- 클러스터링 테이블은 PK 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 PK를 결정해야 한다.

- 클러스터링 인덱스는 세컨더리 인덱스와 달리 모든 컬럼의 내용을 다 가지고 있다
- 클러스터링 인덱스는 PK 값에 의해 저장 위치가 결정되므로 인덱스 알고리즘이라기 보다 테이블 레코드의 저장 방식이라고 볼 수 있다.

### 세컨더리 인덱스가 미치는 영향

- InnoDB 스토리지 엔진의 세컨더리 인덱스는 PK 값을 저장하도록 구현됨
  - 실제 위치(주솟값)가 변경된다 해도 세컨더리 인덱스가 변경되지 않아도 된다.

### 클러스터링 인덱스의 장점과 단점

- 장점
  - PK로 검색할 때 처리 성능이 매우 빠름 (ex. PK 범위 탐색)
  - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
  - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값이 클 경우 전체적으로 인덱스 크기가 커짐
  - 세컨더리 인덱스를 통해 검색할 때, PK로 다시 한 번 검색해야 하므로 처리 성능이 느림
  - `INSERT`할 때 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
  - PK를 변경할 때 레코드를 `DELETE`하고 `INSERT`하는 작업이 필요함

### 클러스터링 테이블 사용 시 주의사항

- 클러스터링 인덱스 키의 크기
  - PK의 크기가 커지면 모든 세컨더리 인덱스의 크기가 커지므로 PK는 신중히 선택하자
- PK는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성
- PK는 반드시 명시할 것
  - PK를 명시하지 않으면 InnoDB 스토리지 엔진 내부적으로 일련번호 칼럼을 추가하므로, AUTO-INCREMENT 칼럼을 추가하는 것과 사실 상 동일하다
- AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
  - PK 크기가 길어도 세컨더리 인덱스가 필요하지 않다면 그대로 PK를 사용하는 것이 좋다
  - 세컨더리 인덱스도 필요하도 PK 크기도 길다면 AUTO-INCREMENT 칼럼을 추가하고 이를 PK로 설정하면 된다.
  - 조회보다는 `INSERT` 위주의 테이블들은 AUTO-INCREMENT를 이용한 인조 식별자를 사용하는 것이 성능 향상에 도움이 된다

## 8.9 유니크 인덱스

- 유니크 인덱스와 논유니크 인덱스는 구조상 아무런 차이점이 없다

### 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 인덱스 읽기 : 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다
- 인덱스 쓰기
  - 중복된 값이 있는지 없는지 체크하는 과정이 필요하므로 상대적으로 느리다
  - MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 자주 발생한다
  - InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용된다

### 유니크 인덱스 사용 시 주의사항

- 성능이 더 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 사용하는 것은 좋지 않다
- MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.
- 결론적으로 유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 한 번씩 고려해 보자

## 8.10 외래키

- 외래키 인덱스 특징
  - 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
  - 외래키가 제거되지 않은 상태에서 자동으로 생성된 인덱스를 삭제할 수 없다.

- InnoDB의 외래키 관리 특징
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에는 잠금 경합(잠금 대기)이 발생한다.
  - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

- 고려해야 하는 사항
  - DB에거 외래 키를 물리적으로 생성하려면 잠금 경합까지 고려해 모델링을 진행하는 것이 좋다.
  - 물리적인 외래키(직접 입력하는 PK를 통한 외래키)의 고려 사항은 자식 테이블의 변경에도 부모 테이블의 읽기 락이 걸린다는 것이다.
  - 이러한 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.
