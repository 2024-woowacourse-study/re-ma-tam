# 09. 옵티마이저와 힌트

## 9.1 개요

### 1. 쿼리 실행 절차

- MySQL에서 쿼리 실행 과정
    1. 사용자로부터 요청된 SQL 문장을 잘게 쪼갠다 (파스 트리)
    2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다. (실행 계획 만들기)
        1. 불필요한 조건 제거 및 연산 단순화
        2. 여러 테이블의 조인이 있는 경우, 읽을 테이블 순서 결정
        3. 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
        4. 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는 지 결정
    3. 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 가져온다.

### 옵티마이저의 종류

- 규칙 기반 최적화 (Rule-based Optimizer)
    - 통계 정보를 조사하지 않고 실행 계획이 수립되기 때문에, 같은 쿼리에 대해서는 항상 같은 실행 방법을 만들어 낸다.
    - 사용자의 데이터는 분포가 다양하기 때문에 오래전부터 많은 DBMS에서 사용하지 않는 방법이다.
- 비용 기반 최적화 (Cost-based Optimizer)
    - 현재 대부분의 DBMS에서 사용
    - 쿼리를 처리하기 위한 여러가지 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.

# 9.2 기본 데이터 처리

### 1. 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔
    - 인덱스를 사용하지 않고 데이터를 처음부터 끝까지 읽어서 처리하는 방법
- 풀 테이블 스캔을 사용하는 경우
    - 테이블의 레코드 건 수가 작은 경우 (테이블에 페이지가 1개인 경우)
    - `WHERE` 절이나 `ON` 절에 사용할 인덱스가 없는 경우
    - 옵티마이저가 판단하기에 조건이 일치하는 레코드 건 수가 너무 많은 경우

- 리드 어헤드(Read ahead) [InnoDB 스토리지 엔진]
    - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것
    - 풀 테이블 스캔이 시작되면, 처음 몇 개 데이터 페이지는 포그라운드 스레드에서 작업하고 특정 시점부터는 백그라운드 스레드로 넘긴다.
    - MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 이용해 언제 리드 어헤드를 시작할지 임계값을 정할 수 있다.
    - 풀 테이블 스캔과 풀 인덱스 스캔에서 모두 사용한다.
      ```mysql
        SELECT COUNT(*) FROM employees; -- 풀 인덱스 스캔을 사용 (용량이 적음)
        SELECT * FROM employees; -- 풀 테이블 스캔 사용
        ```

### 2. 병렬 처리

- MySQL 8.0부터 처음으로 MySQL 서버에서 쿼리의 병렬 처리가 가능해졌다.
    - `innodb_parallel_read_threads` 시스템 변수를 통해 최대 몇 개의 스레드를 이용해서 처리할 지를 변경할 수 있다.
    - `WHRER` 조건 절 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.
    - 해당 스레드 개수가 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있다.

### 3. ORDER BY 처리(Using filesort)

- 인덱스를 이용한 Sort
    - 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 빠르다.
    - `INSERT`, `UPDATE`, `DELETE` 작업 시에 부가적인 인덱스 추가/삭제가 필요하다
    - 디스크 공간과 InnoDB 버퍼 풀 공간(메모리 공간)이 더 필요하다.
- Filesort 이용
    - `INSERT`, `UPDATE`, `DELETE` 작업 시에 부가적인 작업이 필요 없다
    - 정렬해야 될 레코드가 많지 않다면, 충분히 빠르다
    - 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다

- 모든 정렬 인덱스를 이용하도록 튜닝하기란 불가능에 가깝타
    - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
    - `GROUP BY`, `DISTINCT` 같은 처리의 결과를 정렬해야 하는 경우
    - `UNION`의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야 하는 경우

#### 소트 버퍼
- 소트 버퍼 : MySQL에서 정렬을 수행하기 위해 별도의 메모리 공간을 할당받은 공간
    - `sort_buffer_size` 시스템 변수로 설정 가능
    - 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템에 반납함

- 정렬해야 할 레코드의 건 수가 소트 버퍼로 할당된 공간보다 큰 경우
    - 메모리의 소트 버퍼에서 정렬을 수행하고 그 결과를 임시로 디스크에 기록한다.
    - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행한다. (Multi Merge)
    - 레코드 건 수가 많을수록 멀티 머지의 횟수가 많아진다
- 소트 버퍼를 크게 설정한다 해도 실제 벤치마크 결과는 크게 차이나지 않았다.
    - 리눅스 계열의 OS에서는 너무 큰 `sort_buffer_size`를 사용하는 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수도 있다.
    - 정렬을 위해 사용하는 소트 버퍼는 세션 메모리 영역레 해당하므로 , 여러 클라이언트가 공유해서 사용할 수 없다.
    - 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커진다.
    - 일반적인 트랜잭션 처리용 MySQL 서버의 소트 크기는 56KB에서 1MB미만이 적절해보인다.

#### 정렬 알고리즘
- 싱글 패스(Single-pass) 정렬 방식
    - 소트 버퍼에서 `SELECT` 대상이 포함된 칼럼을 전부 담아서 정렬을 수행하는 방식
- 투 패스(Two-pass) 정렬 방식
    - 정렬 대상 컬럼, PK 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 PK로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용한다.
    - 레코드의 크기가 `max_length_for_sort_data`보다 클 때, `BLOB`나 `TEXT` 타입의 컬럼이 SELECT 대상에 포함될 때 투 패스 정렬 방식을 사용한다.

- 쿼리에 따른 정렬 방식
    - 인덱스를 이용한 정렬 : 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다
    - 조인의 드라이빙 테이블만 정렬 : 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행한다.
    - 임시 테이블을 이용한 정렬 : 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.
        - 실행 계획 Extra : "Using temporary; Using filesort"

- 정렬 처리 방법의 성능 비교
    - 스트리밍 방식 : 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
        - 첫 레코드를 전달받게 되기까지의 응답 시간이 짧다
    - 버퍼링 방식 : 결과를 모아서 가공해서 보내주는 방식
        - `ORDER BY`나 `GROUP BY`의 작업이 들어간다면 클라이언트는 작업이 끝날 때까지 기다려야 한다.
    - 가능하다면 인덱스를 사용한 정렬로 유도하고, 최소한 드라이빙 테이블만 정렬되는 수준으로 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다.

### 4. GROUP BY 처리

- `GROUP BY`에 사용된 조건은 인덱스를 사용해서 처리할 수 없으므로 `HAVING`절을 튜닝하려고 다른 방법을 고민할 필요 없다.

- 타이트 인덱스 스캔 (인덱스 스캔을 이용하는 `GROUP BY`)
    - 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그룹핑할 때, 이미 해당 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 작업을 수행한다.
    - 실행 계획 Extra에 별도로 표기되지 않는다.
- 루스 인덱스 스캔을 이용하는 `GROUP BY`
    - 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 방식이다.
    - MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 `GROUP BY` 처리에만 사용할 수 있다. 또한 Prefix Index는 루스 인덱스 스캔으로 사용할 수 없다.
    - 실행 계획 Extra : "Using index for group-by"
- 임시 테이블을 사용하는 `GROUP BY`
    - 인덱스를 전혀 사용하지 못할 때, 사용하는 방식
    - 실행 계획 Extra : "Using temporary"

### 5. DISTINCT 처리

- `DISTINCT`가 사용되는 쿼리의 실행 계획에서 `DISTINCT` 처리가 인덱스를 사용하지 못 할 때는 항상 임시 테이블이 필요하다
    - 하지만 실행 계획의 Extra에는 "Using temporary" 메시지가 출력되지 않는다.

- `SELECT DISTINCT ...`
    - 이 경우에는 `GROUP BY`와 동일한 방식으로 처리된다.
    - `SELECT` 절에 사용된 `DISTINCT` 키워드는 조회되는 모든 칼럼에 영향을 끼진다.
- 집합 함수와 함께 사용된 `DISTINCT`
    - 집합 함수 내 사용된 `DISTINCT`는 그 집합 함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져온다.
        - 내부적으로는 집계 함수 내 `DISTINCT`를 처리하기 위해 임시 테이블을 사용하지만, 실행 계획에서는 "Using temporary"를 표기하지 않는다.
    - 인덱스된 칼럼에 개해 `DISTINCT` 처리를 수행할 때는 임시 테이블 없이 최적화된 처리를 수행할 수 있다.

### 6. 내부 임시 테이블 활용

- MySQL이 사용하는 내부 임시 테이블(Internal temporary table)은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다
    - 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.

- 버전 별 내부 임시 테이블
    - MySQL 8.0 이전 : 메모리 - MEMORY, 디스크 - MyISAM
    - MySQL 8.0 이후 : 메모리 - TempTable, 디스크 - InnoDB
    - MEMORY 가변 길이 타입이 지원이 안되 메모리 낭비가 심했고, MyISAM은 트랜젝션 지원이 안되어 변경됨

- 임시 테이블이 필요한 쿼리
    - `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
    - `ORDER BY`나 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번쨰 테이블이 아닌 쿼리
    - `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우
    - `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
    - `UNION`이나 `UNION DISTINCT`가 사용된 쿼리 (select type: UNION RESULT)
    - 쿼리 실행 계획에서 select type이 DERIVED인 경우
    - 이 밖에도 인덱스를 사용하지 못할 때는 임시 테이블을 생성해야 할 때가 많다
- 쿼리 실행 계획에서 "Using Temporary"라고 사용되지 않는 경우(하위 5개)에도 임시 테이블을 사용할 수 있다.
    - 일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 처리 성능이 상당히 느리다

- 임시 테이블이 디스크에 생성되는 경우
    - `UNION`이나 `UNION ALL`에서 `SELECT`되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
    - `GROUP BY`나 `DISTINCT` 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
    - 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 (TempTable 스토리지 엔진) temp_max_ram 시스템 변수 값보다 큰 경우
- 임시 테이블 생성되었는지 확인하기 위해서는 `SHOW SESSION STATUS LINE 'Created_tmp%;`를 확인해보자.

## 9.3 고급 최적화

### 1. 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어
    - `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식
    - `SET_VAR` 옵티마이저 힌트를 통해 현재 쿼리에만 설정할 수도 있다

- 옵티마이저 스위치 옵션 종류

    - MRR과 배치 키 액세스 (`mrr`, `batched_key_access`)
        - MRR(Multi-Range Read) : 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링한다. 조인 버퍼에 레코드가 다 차면 스토리지 엔진으로 한번에 요청한다.
        - BKA(Batched Key Access) : MMR을 응용해서 실행되는 조인 방식 (기본값 off)

    - 블록 네스티드 루프 조인 (`block_nested_loop`)
        - 조인 버퍼가 사용되는 네스티드 루프 조인 (이중 반복문 조인)
        - MySQL 8.0.20 부터는 블록 네스티드 루프를 사용하지 않고, 해시 조인 알고리즘으로 대체되어 사용된다.

    - 인덱스 컨디션 푸시다운 (`index_condition_pushdown`)
        - **인덱스에 포함된 필드**라면 스토리지 엔진으로 전달하여 **최대한 스토리지 엔진에서 걸러낸 데이터**만 MySQL (MariaDB) 엔진에만 전달
        - 인덱스 조건을 스토리지 엔진으로 넘겨주기 때문에 **인덱스 컨디션 푸시 다운**이라 불린다.
        - [참고 자료 : MySQL (MariaDB) 인덱스 컨디션 푸시다운](https://jojoldu.tistory.com/474)

    - 인덱스 확장 (`use_index_extensions`)
        - InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 PK를 활용할 수 있게 할지를 결정하는 옵션 ex. 복합 PK

    - 인덱스 머지 (`index_merge`)
        - 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리
        - 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 그 조건을 만족하는 레코드 건 수가 많을 것으로 예상될 때 인덱스 머지 실행 계획을 선택한다.
        - 종류) 교집합 (`index_merge_intersection`), 합집합 (`index_merge_union`), 인덱스 머지 - 정렬 후 합집합 (`index_merge_sort_union`)

    - 세미 조인 (`semijoin`) : 실제 조인을 사용하지 않고, 다른 테이블에서 조건이 일치하는 레코드가 있는지만 체크하는 형태의 쿼리
        - 테이블 풀-아웃 (Table Pull-out) : 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
        - 퍼스트 매치 (`firstmatch`) : `IN(subquery)` 형태의 세미 조인을 `EXISTS(subquery)` 형태로 튜닝한 것과 비슷한 방법으로 실행
            - 서브쿼리가 아니라 조인으로 풀어서 실행하면서 일치하는 첫 번째 레코드만 검색하는 최적화를 진행
        - 루스 스캔 (`loosescan`) : 인덱스를 사용하는 `GROUP BY` 최적화 방법에서 살펴본 "Using index for group-by"의 루스 인덱스 스캔과 비슷한 방식의 읽기 사용
        - 구체화 (`materialization`) : 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다.
        - 중복 제거 (Duplicated Weed-out) : 세미 조인 서브쿼리를 일반적인 `INNER JOIN` 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법

    - 컨디션 팬아웃 (condition_fanout_filter) : 해당 테이블의 조건 뿐만 아니라 조인하는 테이블의 나머지 조건도 고려하여 테이블 실행 계획을 세운다.

    - 파생 테이블 머지 (`derived_merge`) : MySQL 5.7부터 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 최적화한다.

    - 인비저블 인덱스 (`use_invisible_indexes`) : MySQL 8.0부터 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공한다.
        - ex. `ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE`

    - 스킵 스캔 (`skip_scan`) : MySQL 8.0부터 여러 조건 중 특정 조건에 대해서만 인덱스가 있는 경우, 조건에 해당하지 않는 부분들을 건너뛰며 결과를 만들 수 있다.

    - 해시 조인 (`hash_join`) : MySQL 8.0.18부터 동등 조인, MySQL 8.0.20부터 모든 조인에 네스티드 루프 조인 대신 사용
        - 네스티드 루프 조인보다 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 덜 걸린다.
        - 자세한 사항은 Real MySQL 8.0 357p 참고

    - 인덱스 정렬 선호 (`prefer_ordering_index`) : MySQL 8.0.21부터 옵티마이저가 `ORDER BY`를 위한 인덱스에 너무 가중치를 부여하지 않기 위해 도입

### 2. 조인 최적화 알고리즘

- Exhausive 검색 알고리즘
    - MySQL 5.0 이전 버전에 사용
    - `FROM` 절에 명시된 모든 테이블 조합에 대해 실행 계획 비용을 계산해서 최적의 조합 1개를 찾는 방법
    - 테이블이 n개라면, n!개의 실행 계획 비용을 계산해야 한다.
- Greedy 검색 알고리즘
    1. n개 중 k개(`optimizer_search_depth`)의 최적 비용을 계산해서 1가지 방법을 고름
    2. 맨 앞 테이블을 고정하고 n-1개 중 k개, ... 형식으로 반복

## 9.4 쿼리 힌트

### 1. 인덱스 힌트

- 인덱스 힌트의 ANSI-SQL 표준
    -  `STRAIGHT_JOIN`, `USE INDEX` 등을 포함한 인덱스 힌트들은 SQL 문법에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SQL 표준 문법을 준수하지 못하게 된다
    - MySQL 5.6부터 추가된 옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석하기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다.

- `STRAIGHT_JOIN`
    - `SELECT`, `UPDATE`, `DELETE` 쿼리에서 여러 개의 테이블이 조인되는 경우, 조싱ㄴ 순서를 고정하는 역할을 한다.
  ```sql
  -- employees, dept_emp, departments 순서대로 조인을 실시한다.
  SELECT /*! STARIGHT_JOIN */
  e.first_name, e.last_name, d.dept_name
  FROM employees e, dept_emp de, departments d
  WHERE e.emp_no = de.emp_no
  AND d.dept = de.dept_no
  ```
    - `STARIGHT_JOIN` 추천 순서
        - 임시 테이블 vs 일반 테이블 : 일반적으로 (인덱스가 없는) 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
        - 임시 테이블끼리 조인 : 임시 테이블은 항상 인덱스가 없기 때문에 크기가 작은 테이블을 드라이빙 테이블로 선정
        - 일반 테이블끼리 조인 : 인덱스가 없는 테이블, 건수자 작은 테이블을 드라이빙 테이블로 선택하는 것이 좋다.
    - 비슷한 역할을 하는 옵티마이저 힌트 : `JOIN_FIXED_ORDER`, `JOIN_ORDER`, `JOIN_PREFIX`, `JOIN_SUFFIX`

- `USE INDEX`, `FORCE INDEX`, `IGNORE INDEX`
    - 인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.
    - `USE INDEX` : 가장 자주 사용되는 힌트 인덱스, MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트
    - `FORCE INDEX` : USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트
    - `IGNORE INDEX` : 특정 인덱스를 사용하지 못하게 하는 용도로 사용하는 힌트
    - 힌트 용도도 명시 가능 (ex. `USE INDEX FOR JOIN`, `USE INDEX FOR ORDER BY`, `USE INDEX FOR GROUP BY`)
    - 인덱스의 사용법이나 좋은 실행 계획이 어떤 것인지 파악하기 힘들다면 힌트를 사용해 강제로 옵티마이저의 실행 계획에 영향을 미치는 것은 피하는 것이 좋다.

- `SQL_CALC_FOUND_ROWS`
    - `SQL_CALC_FOUND_ROWS`가 포함된 쿼리의 경우에는 `LIMIT`을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다.
    - ex) `SELECT SQL_CALC_FOUND_ROWS * FROM employees LIMIT 5;`
    - `SQL_CALC_FOUND_ROWS`는 성능 향상을 위해 만들어진 힌트가 아니라 개발자의 편의를 위해 만들어진 힌트이다.

### 2. 옵티마이저 힌트

- 옵티마이저 힌트 종류
    - 인덱스 : 특정 인덱스의 이를을 사용할 수 있는 옵티마이저 힌트
    - 테이블 : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
    - 쿼리 블록 : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트 (힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트)
    - 글로벌 : 전체 쿼리에 대해서 영향을 미치는 힌트

- 옵티마이저 힌트들 (자세한 내용은 Real MySQL 8.0 382p 참고)
    - `MAX_EXECUTION_TIME` : 쿼리의 최대 시간 설정
    - `SET_VAR` : MySQL 시스템 변수 조정 (조인 버퍼 크기, 정렬용 버퍼 크기 조정 등에 사용 가능)
    - `SEMIJOIN`, `NO_SEMIJOIN` : 세미 조인 최적화 전략을 선택
    - `SUBQUERY` : 세미 조인 최적화가 사용되지 못할 때 최적화 방법
    - `BNL`, `NO_BNL` : MySQL 8.0.20 이후 버전에서
        - `HASHJOIN`, `NO_HASHJOIN` : MySQL 8.0.20 이전 버전에서 사용
    - `JOIN` 관련 힌트
        - `JOIN_FIXED_ORDER` : `STRAIGHT_JOIN`과 동일하게 `FROM`절의 테이블 순서대로 조인을 실행하게 하는 힌트
        - `JOIN_ORDER` 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트 ex. `JOIN_ORDER(d, de)`
        - `JOIN_PREFIX` : 조인에서 드라이빙 테이블만 강제하는 힌트
        - `JOIN_SUFFIX` : 조인에서 드리븐 테이블만 강제하는 힌트
    - `MERGE`, `NO_MERGE` : MySQL 5.7, 8.0에서 임시 테이블을 사용하지 않게 `FROM` 절의 서브 쿼리를 외부 쿼리와 병합을 강제하는 힌트
    - `INDEX_MERGE`, `NO_INDEX_MERGE` : 여러 인덱스를 통해 검색된 레코드로부터 교집합 또는 합집합만을 구해서 결과를 반환하는 것을 가능/불가능하게 하는 힌트
    - `NO_ICP` : ICP(Index Condition Pushdown)를 비활성화
    - `SKIP_SKAN`, `NO_SKIP_SCAN` : 스킵 스캔 기능을 사용하지 않게 하는 기능
        - 옵티마이저가 유니크한 값의 개수를 제대로 분석하지 못하거나 잘못된 경로로 인해 비효율적인 스킵 스캔을 할 경우 `NO_SKIP_SKAN`을 사용
