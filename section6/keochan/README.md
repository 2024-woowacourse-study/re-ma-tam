# 10. 실행 계획

- 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있지 않다.
- DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다.

## 10.1 통계 정보

- MySQL 5.7까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
  - 테이블 칼럼 값들이 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 께획의 정확도가 떨어지는 경우가 많았다.
- MySQL 8.0부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해 저장하는 히스토그램 정보가 도입되었다.

### 1. 테이블 및 인덱스 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보이다.
  - ex. 1억 건의 레코드가 있는 줄 모르고 풀 테이블 스캔을 한다면, 1시간이 소요될 수 있다.
- MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용한다
  - 다른 DBMS보다 통계 정보의 정확도가 높지 않고 통계 정보의 휘발성이 강했다. (특정 이벤트가 발생하면 자동으로 통계 정보가 갱신된다.)
  - MySQL 5.6부터는 통계 정보의 정확성을 높일 수 있는 방법이 제공되기 시작했지만 아직도 많은 사용자가 기존 방식을 그대로 사용한다.

- MySQL 서버의 통계 정보
  - MySQL 5.6부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다. (`innodb_index_stats`, `innodb_table_stats` 테이블로 관리)
  - 테이블 생성 시 `STATS_PERSISTENT` 옵션을 설정하여 테이블 단위로 영구적인 통곚 ㅓㅇ보를 보관할지 말지를 결정할 수 있다.
    ```sql
    CREATE TABLE tab_test(fd1 INT, fd2 VARCHAR(20), PRIMARY KEY(fd1))
    ENIGNE=InnoDB
    STATS_PERSISTENT=DEFAULT
        ```
  - 동계 정보 관련 추가 내용은 Real MySQL 8.0 397p 참고

- MySQL 5.6 버전에 추가된 시스템 변수
  - `innodb_stats_transient_sample_pages` : 자동으로 통계 정보 수집이 실행될 때 해당 개수 페이지만 임의로 샘플링해서 분석하고 통계 정보로 활용함 (기본 값 8)
  - `innodb_stats_persistence_sample_pages` : `ANALYZE TABLE` 명령이 실행되면 임의로 해당 개수 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용함 (기본 값 20)

### 2. 히스토그램

- 히스토그램 정보 수집 및 삭제
  - MySQL 8.0에서 히스토그램 정보는 칼럼 단위로 관리, `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리
  - 수집된 히스토그램 정보는 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리 히스토그램 정보를  `information_schema` 데이터베이스의 `column_statustics` 테이블로 로드한다.

  - MySQL 8.0에서 히스토그램 타입
    - Singleton (Value-Based, 도수 분포) : 칼럼값 개별로 레코드 건수를 관리
    - Equi-Height (Height-Balanced) : 칼럼값의 범위를 균등한 개수로 구분해서 관리

  - 히스토그램 삭제
    - 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의하자
    ```sql
    -- 히스토그램 삭제
    ANALYZE TABLE employees.employees
    DROP HISTOGRAM ON gender, hire_date;
    -- 히스토그램 사용 안하게 하기 (condition_fanout_filter가 다른 최적화 옵션에 영향을 줄 수 있다)
    SET GLOBAL optimizer_switch='condition_fanout_filter=off';
        ```

- 히스토그램의 용도
  - 히스토그램이 없다면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
  - 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만, 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다
    - ex. 조인에서 드라이빙 테이블 결정

- 히스토그램과 인덱스
  - 인덱스 다이브 (Index Dive) : 조건절에 일치하는 레코드 건 수를 예측하기 위해 B-Tree를 샘플링해서 살펴보는 작업
  - MySQL 8.0 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우, 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
    - 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있다.

### 3. 코스트 모델

- 코스트 모델 : 전체 쿼리 비용을 계산하는 데 필요한 단위 작업들의 비용
  - MySQL 8.0으로 업그레이드 되면서 비로소 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다.
  -

- 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다.
- 코스트 모델 영향
  - `key_compare_cost` : 해당 값을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
  - `row_evaluate_cost` : 해당 값을 높이면 풀 스캔을 실행하는 비용이 높아지고, 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
  - `disk_temp_table_create_cost`, `disk_temp_table_row_cost` : 해당 값을 높이면 옵티마이저는 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
  - `memory_temptable_create_cost`, `memory_temptable_row_cost` : 해당 값을 높이면 옵티마이저는 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
  - `io_block_read_cost` : 해당 값을 높이면 옵티마이저는 가능하면 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
  - `memory_block_read_cost` : 해당 값을 높이면 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.

## 10.2 실행 계획 확인

### 1. 실행 계획 출력 포멧

- MySQL 8.0부터 `EXPLAIN EXTENDED`, `EXPLAIN PARTITIONS` 명령이 구분되지 않아 `PARTITIONS`, `EXTEND` 옵션은 문법에서 제거되었다
- MySQL 8.0부터 `FORMAT` 옵션을 사용해 실행 계획 표시 방법을 선택할 수 있다
  - ex) `TABLE` (default), `JSON`, `TREE`
  - 포멧 옵션별로 표시되는 정보의 차이는 있을 수 있으나, MySQL 옵티마이저가 수립한 실행 계획의 큰 흐름을 보여주는 데는 큰 차이가 없다

### 2. 쿼리의 실행 시간 확인

- MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.
  - `EXPLAIN ANALYZE`는 항상 TREE 포멧으로 보여준다.
- `EXPLAIN ANALYZE` 쿼리 실행 순서 보는 방법
  - 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
  - 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행

- `EXPLAIN ANALYZE`의 의미 있는 키워드
  ```plain
  -> Index lookup on s using PRIMARY (emp_no=e.emp_no) (cost=0.98 rows=10)
          (actual time=0.007...0.009 rows=10 loops=233)
    ```
  - `actual time=0.007...0.009` : `employees` 테이블에서 읽은 `emp_no` 값을 기준으로 `salaries` 테이블에서 일치하는 레코드를 검색하는 데 걸린 시간 (ms)
    - 앞의 값 - 걸린 평균 시간, 뒤의 값 - 마지막 레코드를 가져오는 데 걸린 시간
  - `rows=10` : `employees` 테이블에서 읽은 `emp_no`에 일치하는 `salaries` 테이블의 평균 레코드 건 수 (`salaries` 테이블ㅇ에서 `emp_no`를 검색해서 평균 10개의 레코드를 모두 가져오는 데 걸린 평균 시간이 0.009ms)
  - `loops=233` : `employees` 테이블에서 읽은 `emp_no`를 이용해 `salaries` 테이블의 레코드를 찾는 작업이 반복된 횟수

- `EXPLAIN ANALYZE` 명령은 실제 쿼리를 실행하고 사용된 실행 계획과 소요 시간을 보여준다.
  - 쿼리의 실행 시간이 아주 많이 걸리는 쿼리라면 `EXPLAIN`을 사용하여 어느 정도 튜닝한 후 `EXPLAIN ANALYZE` 명령어를 실행하는 것이 좋다.

## 10.3 실행 계획 분석

-  explain 예시
```
+----+-------------+--------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+ 
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | 
+----+-------------+--------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+ 
| 1 | SIMPLE | 사원 | NULL | range | PRIMARY | PRIMARY | 4 | NULL | 20080 | 100.00 | Using where | 
+----+-------------+--------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

### 1. id 칼럼

- `SELECT` 문장 하나 당 id 1개가 부여된다
  - JOIN을 했을 경우, 같은 id가 부여된다
  - `SELECT`가 여러 개(ex. 서브 쿼리)인 경우 다른 id가 부여된다

- 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다
  - `EXPLAIN FORMAT=TREE` 명령으로 확인하면 순서를 더 정확히 알 수 있다

### 2. select_type 칼럼

- `SIMPLE` : `UNION`이나 서브 쿼리를 사용하지 않는 단순한 `SELECT` 쿼리
  - 일반적으로 제일 바깥 `SELECT` 쿼리가 `SIMPLE`로 표기된다.
- `PRIMARY` : `UNION`이나 서브 쿼리를 가지는 `SELECT` 쿼리에서 가장 바깥 쿼리
  - 일반적으로 제일 바깥 `SELECT` 쿼리가 `PRIMARY`로 표기된다.

- `UNION` : `UNION`으로 결합하는 단위 `SELECT` 가운데 첫 번째를 제외한 두 번째 이후 단위 쿼리
- `DEPENDENT UNION` : `UNION`이나 `UNION ALL`로 집합을 결합하는 쿼리 중 외부 쿼리에 의해 영향을 받는 쿼리
  - 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행되어야 하므로 일반 `UNION`보다는 처리 속도가 느릴 때가 많다
- `UNION RESULT` : `UNION` 결과를 담아두는 테이블
  - MySQL 8.0부터 `UNION ALL`의 경우 임시 테이블을 사용하지 않도록 개선
  - 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id값은 부여되지 않는다.

- `SUBQUERY` : `FROM` 절 이외에서 사용되는 서브쿼리
  - `FROM`절에서 사용된 서브 쿼리는 `DRIVEN`으로 표시된다.
- `DEPENDENT SUBQUERY` : 서브 쿼리가 바깥쪽 `SELECT` 쿼리에서 정의된 칼럼을 사용하는 경우
  -  안쪽의 서브 쿼리 결과가 바깥쪽 `SELECT` 쿼리의 칼럼에 의존적이기 때문에 `DEPENDENT` 키워드가 붙는다.
  - 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행되어야 하므로 일반 `SUBQUERY`보다는 처리 속도가 느릴 때가 많다.

- `DERIVED` : 단위 `SELECT` 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성
  - MySQL 5.6부터는 옵티마이저의 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.
  - MySQL 8.0부터는 `FROM` 절의 서브 쿼리에 대한 최적화도 많이 개선되어 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리한다.
- `DEPENDENT DERIVED` : 해당 테이블이 레터럴 조인으로 사용됨
  - 레터럴 조인 : 내부 쿼리에서 외부 값을 사용할 수 있는 조인 ([SQL - LATERAL](https://velog.io/@keum0821/SQL-LATERAL))

- `UNCACHEABLE QUERY` : 서브 쿼리 캐시(조건이 똑같은 서브쿼리가 실행될 때 이전 결과를 그대로 재사용) 기능을 사용할 수 없는 서브 쿼리
- `UNCACHEABLE UNION` : 캐시 기능을 사용할 수 없는 `UNION`
- `MATERIALIZED` : 서브 쿼리의 내용을 조건 절에 따라 임시 테이블로 구체화하여 사용

### 3. table 칼럼

- MySQL 서버의 실행 계획은 단위 `SELECT` 기준이 아니라 테이블 기준으로 표시된다.
  - 테이블의 이름에 별칭을 붙였을 경우, 별칭으로 표시된다.
- `<derived N>`, `<union M, N>` 등은 임시 테이블을 의미한다.

### 4. partitions 칼럼

- MySQL 8.0부터는 `EXPLAIN` 명령으로 파티션 관련 실행 계획까지 확인할 수 있다.
- 파티션 프루닝(Partition pruning) : 여러 개인 테이블에서 필요한 파티션 만을 골라내는 과정
  - 실행 계획에서 쿼리 처리를 위해 필요한 파티션만 보여준다.

### 5. type 칼럼

- `system` : 레코드가 0~1건 존재하는 테이블을 참조하는 형태
  - MyISAM, MEMORY 테이블에서만 사용되는 접근 방법

- `const` : PK나 유니크 키 칼럼을 이용하는 `WHERE` 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
  - 프라이머리 키의 일부만 조건으로 사용할 때는 `ref`로 표시된다.
- `eq_ref` : 조인에서 처음 읽는 테이블의 칼럼 값을, 그 다음에 읽어야 할 테이블의 PK나 유니크 칼럼의 검색 조건에 사용할 때
  - 조인에서 두 번째 이후에 읽는 테이블에서 해당 조건의 로우가 반드시 한 건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법
- `ref` : 인덱스의 종류와 관계없이 동등 조건으로 검색할 때 사용된다.
  - 반드시 1건이라는 보장이 없으므로 `const`, `eq_ref`보다 느리다
  - 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법 중 하나
- `const`, `eq_ref`, `ref` 모두 매우 좋은 접근 방법으로 인덱스 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 방법이다.

- `fulltext` : MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법
  - c.f. 전문 검색 인덱스는 통계 정보를 관리하지 않으므로, 전문 검색 쿼리를 사용할 때는 조건 별로 성능을 확인해 보는 것이 좋다.
- `ref_or_null` : `ref` 접근 방법과 같은데, `NULL` 비교가 추가된 형태

- `unique_subquery` : `WHERE` 조건 절에서 사용될 수 있는 `IN`(subquery) 형태의 쿼리를 위한 접근 방법
  - MySQL 8.0에서는 `WHERE` 조건 절 `IN`(subquery)를 최적화하기 위한 많은 기능이 도입되었으므로 보기 힘들 것이다.
  - 서브 쿼리의 반환 값에 중복이 없으므로 별도의 중복 제거 작업이 필요 없음
- `index_subquery` : `unique_subquery` 상황 중 서브 쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있는 경우

- `range` : 인덱스 레인지 스캔 형태의 접근 방법
  - 인덱스를 하나의 값이 아니라 범위로 검색하는 경우
  - `range` 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.
- `index_merge` : 2개 이상 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식
  - 여러 인덱스를 읽어야 하므로 일반적으로 `range` 접근 방법보다 효율성이 떨어진다.
  - 전문 검색 인덱스를 사용하는 쿼리에서는 `index_merge`가 적용되지 않는다.
  - 항상 2개 이상의 집합이 되기 때문에 부가적인 작업이 더 필요하다.
- `index` : 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.
  - 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니라는 점을 잊지 말자
  - 풀 테이블 스캔보다는 빠르게 처리되며, 정렬된 인덱스를 이용할 수 있으므로 훨씬 효율적이라 할 수 있다.

- `ALL` : 풀 테이블 스캔을 의미
  - 가장 마지막에 선택하는 가장 비효율적인 방법
- 일반적으로 `index`, `ALL` 접근 방법은 빠른 응답을 사용자에게 보내야 하는 웹 서비스와 같은 온라인 트랜잭션 처리 환경에는 적합하지 않다.
  - 테이블이 매우 작지 않다면 실제로 테이블에 데이터를 어느 정도 저장한 상태에서 쿼리의 성능을 확인해 보고 적용하는 것이 좋다.

### 6. possible_keys 칼럼

- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록
  - 모든 인덱스가 나오는 경우가 허다하기 때문에 쿼리를 튜닝하는데 크게 도움되지 않는다.
  - possible_keys 칼럼에 인덱스가 나열됐다고 해서 그 인덱스를 사용한다고 판단하지 않도록 주의하자.

### 7. key 칼럼

- 최종 선택된 실행 계획에서 사용하는 인덱스
  - 쿼리를 튜닝할 때는 key 칼럼에서 의도했던 인덱스사 표시되는지 확인하는 것이 중요하다.
- index_merge인 경우에는 2개 이상의 인덱스가 사용될 수 있다.

### 8. key_len 칼럼

- 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값
  - 많은 사용자가 쉽게 무시하는 정보지만 사실 매우 중요한 정보 중 하나
  - 다중 칼럼 또는 단일 칼럼에서 몇 개의 칼럼(&바이트)를 사용했는지 알려주는 정보
- 예시
  - 앞의 특정 정보만을 사용했다면, 해당 바이트만을 표기함
  - `NOT NULL`이 아닌 칼럼에서는 칼럼의 값이 `NULL`이 아님을 표기하기 위해서 1바이트를 추가로 사용하는데, 이 값도 포함한다.

### 9. ref 칼럼

- 접근 방법이 `ref`일 때, 참조 조건으로 어떤 값이 제공됐는지 보여준다. (ex. table.column 형식)
  - 상숫값을 지정했다면, ref 칼럼의 값은 `const`로 표시된다.
  - 다른 테이블의 칼럼 값이라면 그 테이블 명과 칼럼 명이 표시된다.
- 사용자가 명시적으로 값을 변환할 때, MySQL 서버가 내부적으로 값을 변환할 때 ref 칼럼에는 `func`가 출력된다.
  - 내부적으로 값을 변환하는 예시 : 문자 집합이 일치하지 않는 두 칼럼 조인, 숫자 타입과 문자열 타입의 칼럼의 조인
  - 가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되데 조인 컬럼 타입을 일치시키는 것이 좋다.

### 10. rows 칼럼

- 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.
  - 이 값은 스토리지 엔진 별로 가지도 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상 값이라서 정확하지 않다.
  - 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는 지를 의미한다.

### 11. filtered 칼럼

- 읽는 레코드 중 조건에 얼마나 일치할지 예측한 정도 (% 단위)
  - 두 테이블 조인 시, 조건들까지 합친 후 최종적으로 일치하는 레코드 건 수가 적인 테이블을 파악하는 것은 중요하다. (해당 테이블을 드라이빙 테이블로 선정될 가능성이 높다.)
- filtered 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라진다.
  - MySQL 8.0에서는 filtered 칼럼을 더 정확히 예측하기 위해서 히스토그램 기능이 도입됨 (10.1.2절 참고)

### 12. Extra 칼럼

- 칼럼의 이름과 달리, 쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.

- `const row not found` : `const` 접근 방법으로 읽었지만, 해당 테이블에 레코드가 1건도 존재하지 않는 경우
- `Deleting all rows` : 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 사용한 경우 (ex. MyISAM 스토리지 엔진)
- `Distinct` : 중복되지 않는 케이스들을 가져오는 경우
  - 직접적으로 `distinct` 키워드를 사용하지 않아도 경우에 따라 테이블 조인 시 사용될 수 있다
- `FirstMatch` : 특정 테이블 기준 첫 번째로 일치하는 한 건만 검색한다는 것을 의미
- `Full scan on NULL key` : 쿼리를 실행하는 중 특정 칼럼 값이 `NULL`인 경우, 서브쿼리 테이블에 대해 풀 테이블 스캔을 사용할 것임을 알려주는 키워드
  - ex. `col1 IN (SELECT col2 FROM ...)`에서 `col1`이 `NULL`인 경우
    - 서브 쿼리가 1건이라도 있는 경우 `NULL`, 서브 쿼리가 1건도 없는 경우 `FALSE` 처리함
  - `col1` 값이 `NULL`인 레코드가 있고, 서브 쿼리에 개별적으로 `WHERE` 조건이 있다면 상당한 성능 문제가 발생할 수 있다.
- `Impossible HAVING` : `HAVING` 절의 조건을 만족하는 레코드가 없는 경우
  - 위 경우에는 쿼리가 제대로 작성되지 못한 경우가 대부분이므로 쿼리의 내용을 다시 점검하는 것이 좋다.
- `Impossible WHERE` : `WHERE` 절의 조건을 만족하는 레코드가 없는 경우
  - 위 경우에는 쿼리가 제대로 작성되지 못한 경우가 대부분이므로 쿼리의 내용을 다시 점검하는 것이 좋다.
- `LooseScan` : 유니크한 특정 경우만 필요한 경우, 특정 row만 읽어서 사용하는 최적화
  - ex. `SELECT * FROM departments d WHERE d.id IN (SELECT de.department_id FROM department_employment de)`
- `No matching min/max row` : `MIN()`, `MAX()`와 같은 집합 함수가 있는 쿼리의 조건절에서 일치하는 레코드가 한 건도 없을 때
- `no matching row in const table` : `const` 방법으로 접근할 때 레코드가 없는 경우
- `No matching rows after partition pruning` : 해당 파티션에서 `UPDATE`, `DELETE`할 대상 코드가 없는 경우 (대상 파티션이 없음을 의미함)
- `No table used` : `FROM` 절 자체가 없거나, `DUAL`(칼럼과 레코드를 1개씩만 가지는 가상의 상수 테이블)을 사용할 경우
- `Not exists` : 아우터 조인을 통해 안티-조인을 수행하는 경우
  - ex. `SELECT * FROM parent p LEFT JOIN child c ON p.id=c.parent_id WHERE c.parent IS NULL`
  - `child` 조인 조건이 일치하는 레코드가 여러 건 있어도 딱 1건만 조회하여 최적화함
- `Plan isn't ready yet` : 다른 커넥션에서 사용하는 쿼리 조회 시, 아직 실행 계획이 다 세워지지 않은 경우
  - ex. `EXPLAIN FOR CONNECTION 8`
- `Range checked for each record(index map: N)` : 레코드마다 인덱스 레인지 스캔을 체크하는 경우
  - ex. `SELECT * FROM employees e1, employees e2 WHERE e2.emp_no >= e1.emp_no`
- `Recursive` : CTE(Common Table Expression)을 이용해서 재귀 쿼리를 작성한 경우
- `Rematerialize` : 레터럴 조인되는 테이블이 선행 테이블의 레코드 별로 서브 쿼리를 실행해서 결과를 임시 테이블에 저장하는 경우 (11.4.7.6 레터럴 조인 참고)
- `Select tables optimized away` : `SELECT`, `GROUP BY`에 `MIN()`, `MAX()`가 사용되었을 때, 인덱스를 통해 1건만 읽는 형태의 최적화가 적용된 경우
- `Start temporary`, `End temporary` : Duplicate Weed-out 최적화 전략이 사용된 경우
  - Duplicate Weed-out : 불필요한 중복 건을 제거하기 위해서 내부 임시 테이블을 사용하는 경우
  - 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 `Start temporary`, 끝나는 부분에 `End temporary` 문구를 표기한다.
- `unique row not found` : 두 개의 테이블을 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서, 아우터 테이블에 일치하는 레코드가 존재하지 않는 경우
- `Using filesort` : 조회된 레코드를 내부적으로 한 번 정렬하는 경우
- `Using index` : 데이터 파일을 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때
- `Using index condition` : MySQL 옵티마이저가 인덱스 컨디션 푸시다운 최적화를 사용한 경우(9.3.1.3절 참조)
- `Using index for group-by` : 루스 인덱스를 통한 `GROUP BY` 처리
- `Using inde for skip skan` : MySQL 옵티마이저가 인덱스 스킵 스캔 최적화를 사용한 경우 (8.3.4.4 인덱스 스킵 스캔 참조)
- `Using join buffer` : 두 테이블 조인 시, 드리븐 테이블에 적절한 인덱스가 없는 경우
  - 어떤 조인 방식을 이용했는지 괄호로 명시함 ex. `(Block Nested Loop)`, `(Batched Key Access)`, `(hash join)`
- `Using MRR` : MRR(Multi Range Read) 최적화를 사용
  - MRR(Multi Range Read)여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있도록 한다.
- `Using sort_union`, `Using union`, `Using intersect` : `index_merge` 접근 방법을 이용했을 때 명시됨
  - 괄호 안에 인덱스 머지에 사용된 인덱스들이 명시된다.
- `Using temporary` : 쿼리를 처리하는 동안 중간 결과를 담아두기 위해 임시 테이블을 사용하는 경우
- `Using where` : MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업이 필요한 경우
- `Zero limit` : `Limit 0`를 뒤에 붙여 사용한 경우
  - 데이터 값이 아닌 결괏값의 메타데이터만 필요한 경우 `Limit 0`를 붙여 사용하기도 함
