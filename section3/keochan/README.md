# 05. 트랜잭션과 잠금


- 트랜잭션
  - 트랜잭션은 작업의 완전성을 보장
  - Partical update가 발생하지 않게 만들어주는 기능
- 잠금(Lock)
  - 동시성을 제어하기 위한 기능
  - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할
- 격리 수준
  - 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

## 5.1 트랜잭션

### MySQL에서의 트랜잭션

- 트랜잭션은 하나의 논리적인 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해주는 것이다.
- MySQL은 트랜잭션을 보장하기 때문에, 한꺼번에 여러 데이터를 `INSERT` 해도 한번에 다 추가하거나 전부 반영되지 않는다.
  - 반면 MyISAN, MEMORY 스토리지 엔진은 한꺼번에 여러 데이터를 `INSERT`해도 순서에 따라 일부 데이터가 삽입될 수 있다.
  - 이러한 부분 업데이트(Partial Update) 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어낸다.
- 어떤 사용자는 트랜잭션이 상당히 골치 아픈 기능쯤으로 생각하지만, 트랜잭션이란 그만큼 어플리케이션 개발에서 고민해야 할 문제를 줄여주는 아주 필수적인 DBMS의 기능이라는 점을 기억해야 한다.
  - 트랜잭션 없이 2개 이상의 쿼리가 실행되는 경우라면 실패에 대한 재처리 작업은 if-else 구문으로 묶여 매우 골치아픈 처리가 된다.

### 주의 사항

- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
  - 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 의미이다.
  - 프로그램의 코드에서 라인 수는 한두 줄이라고 하더라도 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.
- 위와 같은 실수로 인해 DBMS 서버가 높은 부하로 빠지거나 위험한 상태에 빠지는 경우가 빈번ㄴ히 발생한다.

## 5.2 MySQL 엔진의 잠금

- MySQL에서 사용되는 잠금
  - MySQL 엔진 레벨 잠금 : 모든 스토리지 엔진에 영향을 미침
  - 스토리지 엔진 레벨 잠금 : 스토리지 엔진 간 상호 영향을 미치지 않음

### 글로벌 락
- 글로벌 락
  - `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다.
  - MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
  - 한 세션이 글로벌 락을 획득하면 다른 세션에서 `SELECT`를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
  - 글로벌 락이 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 DB가 다르더라도 동일하게 영향을 미친다.
    - MyISAM이나 MEMORY 테이블에 대해 `mysqldump`로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다.

- 백업 락
  - InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다.
  - MySQL 8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생김
  - MySQL 8.0부터는 Xtrabackup이나 Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.
    ```mysql
      LOCK INSTANCE FOR BACKUP; -- 백업 락 실행
      UNLOCK INSTANCE; -- 백업 락 해제
      ```
  - 특정 세션에서 백업 락을 획득하면 모든 세션에서 다음과 같이 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
    - ex) DB 및 테이블 등 모든 객체 생성 및 삭제, `REPAIR TABLE`과 `OPTIMIZE TABLE` 명령, 사용자 관리 및 비밀번호 변경
    - 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.

### 테이블 락
- 명시적인 테이블 락
  - 개별 테이블 단위로 설정되는 잠금
  - 얻는 방법 : `LOCK TABLE table_name [READ | WRITE]`
  - 반납 방법 `UNLOCK TABLE`
  - 테이블 락은 MyISAN, InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정 가능
  - 명시적인 테이블 락도 특별한 상황이 아니라면 애플리케이션에서 사용할 필요가 거의 없다.

- 묵시적인 테이블 락
  - MyISAN이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
    -  MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 변경 후 잠금을 해제하는 형태
  - InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 단순 데이터 변경으로는 테이블 락이 설정되지 않는다.
  - InnoDB 테이블에는 스키마를 변경하는 쿼리의 경우에만 영향을 미친다.

### 네임드 락

- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정
  - 단순히 사용자가 지정한 문자열에 대해 획득하고 반납(해제)하는 과정
- 네임드 락은 자주 사용되지 않는다.
- MySQL 8.0부터 네임드 락을 중첩해서 사용 가능

- 용도
  - 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.
  - 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
    - 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드락을 걸고 쿼리를 실행하여 해결

### 메타데이터 락

- DB 객체(테이블, 뷰, ...)의 이름이나 구조를 변경하는 경우 획득하는 락
- 획득 방법 : `RENAME TABLE table_a TO table_b`
  - 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정
  - `RENAME TABLE rank TO rank_backup, rank_new TO rank`와 같은 명령어로 실시간으로 `rank_new`를 `rank`로 대체할 수 있다.

- (데이터가 많을 때) 테이블 구조 변경 방법 (Real MySQL 165p 참고)
  - 데이터를 여러 개의 스레드를 이용해 기존 데이터 복사
  - 작업 대상 테이블 2개에 쓰기 락을 걸고, 최근 데이터까지 복사
  - 다 옮겨지면, RENAME 명령어로 새로운 테이블을 서비스에 투입

## 5.3 InnoDB 스토리지 엔진 잠금

- MySQL에서 지원하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금을 지원함
  - MyISAN에 비해 뛰어난 동시성 처리가 가능
  - 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진 단위 잠금은 MySQL 명령을 통해 접근하기 상당히 까다로움

- InnoDB 잠금 이용하기
  - 예전 버전에서는 InnoDB 테이블을 생성해 잠금 정보를 덤프하는 방법과 `SHOW ENGINE INNODB STATUS`가 전부였다. (내용도 보기 어려움)
  - 최근 버전에는 InnoDB의 트랜잭션과 잠금, 잠금 대기중인 트랜잭션 목록을 조회할 수 있다.
  - 최근 버전에는 장시간 잠금을 가지고 있는 클라이언트를 찾아 종료시킬 수도 있다.

### InnoDB 스토리지 엔진의 잠금

- 레코드 기반의 잠금 기능 제공
- 잠금 정보가 상당히 작은 공간으로 관리되기 떄문에 락이 더 큰 범위로 레벨업되는 경우는 없다.
  - ex) 레코드 락이 페이지 락으로 또는 테이블 락이 되는 경우는 없다.

- 레코드 락 (Record Lock)
  - 레코드 자체만을 잠그는 락
  - InnoDB 스토리지 엔진은 **인덱스의 레코드를 잠근다.**
    - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
  - PK 또는 유니크 인덱스에 의한 변경 작업에서 사용
- 갭 락
  - 레코드 자체가 아닌, 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
  - 레코드와 레코드 **사이의 간격에 새로운 레코드가 생성되는 것을 제어**
- 넥스트 키 락
  - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
  - 갭 락과 넥스트 키 락의 주목적 : 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것
  - 갭 락과 넥스트 키 락으로 인해 데드락이 발생하거나 다른 트랜잭션이 기다리는 일이 자주 발생함
    - 바이너리 로그 포멧을 ROW 형태로 바궈서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다
- 자동 증가 락
  - `AUTO_INCREMENT` 칼럼 속성에서 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 위한 락
  - 새로운 레코드를 저장하는 쿼리에서만 필요하며, 트랜잭션과 관계없이 `AUTO_INCREMENT`값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
  - `INSERT` 쿼리가 동시에 실행되는 경우, 하나의 쿼리가 자동 증가 락을 걸면 나머지 쿼리는 기다려야 한다.
  - `AUTO_INCREMENT` 락을 명시적으로 획득하고 해제하는 방법은 없으며, 굉장히 짧은 시간에 이루어져 대부분의 경우 문제되지 않는다.
  - INSERT 쿼리가 실패했더라도 한 번 증가된 `AUTO_INCREMENT` 값은 줄어들지 않고 그대로 남는다. (자동 증가 락을 최소화하기 위해)

### 인덱스와 잠금

- InnoDB의 잠금은 인덱스를 잠그는 방식으로 처리된다.
  - 즉 , 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
  - ex) `first_name`에 대한 인덱스가 걸려 있고, `first_name`, `last_name`으로 조건을 걸어 update하면, `first_name`이 같은 모든 레코드에 락이 걸린다.
- 인덱스가 하나도 없는 경우, 테이블을 풀 스캔하면서 `UPDATE` 작업을 하며, 모든 레코드를 잠그게 된다.

### 레코드 수준의 잠금 확인 및 해제

- 레코드 수준 잠금 확인의 어려움
  - 테이블 잠금에서는 잠금의 대상이 테이블이므로 쉽게 문제의 원인이 발견되고 해결될 수 있다.
  - 레코드 수준의 잠금은 해당 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.
- MySQL 5.1부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행해 보면 잠금과 잠금 대기를 확인할 수 있다.
  - MySQL 5.1 기준 : `information_schema`라는 DB에 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS`라는 테이블을 통해 확인 가능
  - MySQL 8.0부터는 `information_schema` 가 Deprecated되고 있으며, 대신 `performance_schema`의 `data_locks`와 `data_lock_waits` 테이블로 대체되고 있다.
- 잠금 대기의 자세한 해결 방법은 책 174p 참고
  - `KILL 17` 을 통해 잠긴 스레드를 강제 종료할 수 있다.

## 5.4 MySQL의 격리 수준

- 트랜잭션의 격리 수준(isolation level)
  - 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것
  - 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션간의 격리(고립) 정도는 높아지며, 동시 처리 성능이 떨어진다.
  - 사실 `SERIALIZABLE` 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.

| 구분               | Dirty Read | Non-Repeatable Read | Phantom Read     |
| ---------------- | ---------- | ------------------- | ---------------- |
| READ UNCOMMITTED | 발생         | 발생                  | 발생               |
| READ COMMITED    | 없음         | 발생                  | 발생               |
| REPEATABLE READ  | 없음         | 없음                  | 발생 (InnoDB에는 없음) |
| SERIALIZABLE     | 없음         | 없음                  | 없음               |
- 일반적인 온라인 서비스 용도의 DB는 'READ COMMITED'. 'REPEATABLE READ' 수준을 사용한다.
- 오라클과 같은 DBMS는 'READ COMMITED'를 주로 사용한다.

### READ UNCOMMITTED

- 특징
  - 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보인다.
- Dirty Read
  - 어떤 트랜잭션에서 작업이 완료하지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
  - 데이터가 나타났다 사라졌다 하는 현상을 초래하므로 어플리케이션 개발자와 사용자를 상당히 혼란스럽게 만들 것이다.
- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준

### READ COMMITTED

- 특징
  - 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- InnoDB에서의 구현
  - 변경중인 데이터의 `SELECT` 쿼리 결과는 테이블이 아니라 언두 영역에 백업된 레코드에서 가져온다.
  - 변경된 내용을 커밋하면 그떄부터는 다른 트랜잭션에서도 새롭게 변경된 값을 조회할 수 있다.
- Non-Repeatable Read
  - 한 트랜잭션 내에서 똑같은 `SELECT` 쿼리를 실행했지만, 다른 값을 가져오는 경우
  - 'READ COMMITTED'에서는 다른 트랜잭션의 커밋 여부에 따라 한 트랜잭션 내 조회한 값이 바뀔 수 있다.
  - 문제 : 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때, 오늘 입금된 금액의 총합을 조회하는 경우

### REPEATABLE READ

- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용하는 격리 수준
  - 바이너리 로그를 가진 MySQL 서버에서는 최소한 REPEATABLE READ 이상의 격리 수준을 사용해야 한다.
- REPEATABLE READ 수준에서는 Non-Repeatable Read 현상이 발생하지 않음
  - 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경함 (Multi Version Concurrency Control)
  - 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서 동일한 결과를 보여줄 수 있다.
  - READ COMMITED도 MVCC를 이용해 COMMIT 전의 데이터를 보여주지만, 언두 영역에 몇 번째 버전을 보여주냐의 차이가 있다.

- REPEATABLE READ 구현 방식
  - InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되 있다.
  - 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단되는 시점에 주기적으로 삭제한다.
  - REPEATABLE READ 격리 수준에서 MVCC를 보장하기 위해, 실행 중인 트랜잭션 중에 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다.
    - 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존되어야 하기 때문이다.

- REPEATABLE READ 성능
  - 한 사용자가 트랜잭션을 시작하고 장기간 트랜잭션을 종료하지 않으면, 언두 영역이 백업된 데이터로 무한정 커질 수 잇따.
  - 이렇게 언두 영역에 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.

- Phantom Read
  - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상
  - `SELECT ... FOR UPDATE` 쿼리는 SELECT에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다.

### SERIALIZABLE

- 가장 단순하며 가장 엄격한 격리수준
- 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
  - 한 트랜잭션이 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.

- SERIALIZABLE 격리 수준에서 Phantom Read 문제가 발생하지 않는다.
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 수준에서도 이미 Phantom Read 문제가 발생하지 않기 때문에 굳이 SERIALIZABLE을 사용할 필요성은 없다.
