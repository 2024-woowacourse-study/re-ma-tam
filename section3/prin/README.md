# 5. 트랜잭션과 잠금

- [5.1. 트랜잭션](#51-트랜잭션)
    - [5.1.1. MySQL에서의 트랜잭션](#511-mysql에서의-트랜잭션)
    - [5.1.2. 주의사항](#512-주의사항)
- [5.2. MySQL 엔진의 잠금](#52-mysql-엔진의-잠금)
    - [5.2.1. 글로벌 락](#521-글로벌-락)
    - [5.2.2. 테이블 락](#522-테이블-락)
    - [5.2.3. 네임드 락](#523-네임드-락)
    - [5.2.4. 메타데이터 락](#524-메타데이터-락)
- [5.3. InnoDB 스토리지 엔진 잠금](#53-innodb-스토리지-엔진-잠금)
    - [5.3.1. InnoDB 스토리지 엔진의 잠금](#53-innodb-스토리지-엔진-잠금)
        - [5.3.1.1. 레코드 락](#5311-레코드-락)
        - [5.3.1.2. 갭 락](#5312-갭-락)
        - [5.3.1.3. 넥스트 키 락](#5313-넥스트-키-락)
        - [5.3.1.4. 자동 증가 락](#5314-자동-증가-락)
    - [5.3.2. 인덱스와 잠금](#532-인덱스와-잠금)
    - [5.3.3. 레코드 수준의 잠금 확인 및 해제](#533-레코드-수준의-잠금-확인-및-해제)
- [5.4. MySQL의 격리 수준](#54-mysql의-격리-수준)
    - [5.4.1. READ UNCOMMITTED](#541-read-uncommitted)
    - [5.4.2. READ COMMITTED](#542-read-committed)
    - [5.4.3. REPEATABLE READ](#543-repeatable-read)
    - [5.4.4. SERIALIZABLE](#544-serializable)

## 5.1. 트랜잭션
- 작업의 완전성을 보장해주는 것
- 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못했을 떄 원상태로 복구

> 잠금: 동시성 제어 <br/>
> 트랜잭션: 데이터의 정합성 <br/>
> 격리 수준: 하나의 트랜잭션 내, 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

### 5.1.1. MySQL에서의 트랜잭션
- 하나의 쿼리든 두 개 이상의 쿼리든 논리적인 작업 자체가 적용(commit)되거나 적용하지 않아야함(rollback)을 보장
- InnoDB는 트랜잭션을 지원하지만 MyISAM은 트랜잭션을 지원하지 않음

### 5.1.2. 주의사항
- DBMS와 동일하게 꼭 필요한 최소의 코드에만 적용
- 프로그램 코드에서 트랜잭션의 범위를 최소화
- 트랜잭션이 불필요한 범위까지 트랜잭션에 포함되면 커넥션 반납이 늦어짐 ex) 외부 api 호출, 메일 전송

## 5.2. MySQL 엔진의 잠금

### 5.2.1. 글로벌 락
- `FLUSH TABLES WITH READ LOCK` 명령으로 락 획득
- MySQL의 잠금 중 가장 범위가 큼 -> MySQL 서버 전체에 영향
- 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML은 글로벌 락의 영향을 받음
- 데이터베이스가 다르더라도 영향을 미침
- 웹 서비스용으로 사용되는 MySQL 서버는 사용 자제
- `mysqldump`가 내부적으로 글로벌 락을 실행할 때가 있으므로 사용하는 옵션에 따라 어떤 락을 사용하는지 확인 필요
- MySQL 8.0 버전부터 백업 락이 도입됨 `LOCK INSTANCE FOR BACKUP`
    - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제 불가
    - REPAIR TABLE, OPTIMIZE TABLE 명령 불가
    - 사용자 관리 및 비밀번호 변경 불가
    - 일반적인 테이블의 데이터 변경은 가능
    - DDL 명령이 실행되면 복제 일시 중지

### 5.2.2. 테이블 락
- 개별 테이블 단위로 잠금
```sql
LOCK TABLES {테이블명} [READ | WRITE];

UNLOCK TABLES;
```
- 명시적인 테이블 락은 특별한 상황이 아니면 거의 사용할 필요없음
- 묵시적인 테이블 락은 MyISAM, MEMORY 스토리엔진의 테이블에서 데이터 변경 쿼리가 실행되면 발생
- InnoDB 스토리지 엔진의 테이블은 **레코드 기반**의 잠금을 사용하기 때문에 묵시적인 테이블 락이 설정되지 않음
    - 테이블 락은 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침

### 5.2.3. 네임드 락
- `GET_LOCK()` 함수로 임의의 문자열에 대해 잠금 설정
- 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납
```sql
-- ddangkong 문자열에 잠금 획득, 이미 잠금을 사용 중이면 2초 동안만 대기
SELECT GET_LOCK('ddangkong', 2);

-- ddangkong 문자열에 잠금이 설정되어 있는지 확인
SELECT IS_FREE_LOCK('ddangkong');

-- ddangkong 문자열에 설정된 잠금을 반납
SELECT RELEASE_LOCK('ddangkong');
```
- 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용
- 배치 프로그램과 같이 한 번에 많은 레코드를 변경할 때 데드락 해결
- MySQL 8.0 버전부터 네임드 락 중첩 가능
```sql
SELECT GET_LOCK('ddangkong1', 2);
SELECT GET_LOCK('ddangkong2', 2);

-- 현재 세션에서 획득한 네임드 락을 한 번에 모두 반납
SELECT RELEASE_ALL_LOCKS();
```

### 5.2.4. 메타데이터 락
- 테이블, 뷰 등 데이터베이스 객체의 이름이나 구조를 변경할 때 획득하는 잠금
- 명시적으로 획득, 반납할 수 없음
- `RENAME TABLE {이전 테이블 명} TO {이후 테이블 명}`을 사용하면 두 이름 모두 잠금 설정
- 두 개의 RENAME 작업을 한 번에 실행하면 "Table not found '{테이블 명}'" 에러를 회피할 수 있음
```sql
RENAME TABLE member TO member_backup, member_new TO member;
```
- DDL은 단일 스레드로 동작하기 때문에 시간이 오래 소요된다면 여러 문제가 발생할 수 있음
    - 언두 로그 증가
    - 누적된 Online DDL 버퍼 크기
    - 새로운 구조의 테이블 생성 -> 이전 데이터 복사 -> RENAME으로 테이블명을 변경하면 빠르게 처리 가능

## 5.3. InnoDB 스토리지 엔진 잠금
- 레코드 기반 잠금 방식
- 뛰어난 동시성 처리
- 잠금 정보 확인
    - `information_schema` 데이터베이스의 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 조인해서 조회
    - Performance Schema를 이용해서 내부 잠금 모니터링

### 5.3.1. InnoDB 스토리지 엔진의 잠금

#### 5.3.1.1. 레코드 락
- InnoDB 엔진은 레코드 자체가 아닌 **인덱스의 레코드**를 잠금
- 인덱스가 하나도 없는 테이블이더라도 자동으로 생성된 clustered index를 사용

#### 5.3.1.2. 갭 락
- 레코드와 바로 인접한 레코드 사이의 간격만 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 **INSERT**되는 것을 제어
- 넥스트 키 락의 일부로 자주 사용

#### 5.3.1.3. 넥스트 키 락
- 레코드 락 + 갭 락
- STATEMENT 로그 포맷 + `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일하도록 보장하는 것이 목적
- 데드락 또는 다른 트랜잭션을 기다리게 하는 일이 자주 발생
- ROW 로그 포맷을 사용해서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음
    > MySQL 8.0 버전부터 기본 로그 포맷

#### 5.3.1.4. 자동 증가 락
- `AUTO_INCREMENT` 컬럼이 사용된 테이블에 INSERT 쿼리가 발생할 때 잠금
- `AUTO_INCREMENT` 값을 가져오는 순간만 락이 걸렸다가 즉시 해제
- 자동 증가 락은 **테이블 당 하나만 존재**
- 명시적으로 획득하고 해제할 수 없음
- MySQL 5.1 버전 이상부터 `innodb_autoinc_lock_mode` 시스템 변수로 자동 증가 락의 작동 방식을 변경할 수 있음
    - `innodb_autoinc_lock_mode=0`
        - 모든 INSERT 쿼리에 자동 증가 락 사용
    - `innodb_autoinc_lock_mode=1`
        - INSERT되는 레코드 수를 정확히 예측할 수 있을 때 자동 증가 락 대신 **래치(뮤텍스)** 사용
        - 예측할 수 없으면 자동 증가 락 사용
        - 최소한 하나의 INSERT 쿼리에서 저장되는 레코드는 연속된 자동 증가 값을 가짐
        - 연속 모드(Consecutive mode)
    - `innodb_autoinc_lock_mode=2`
        - 무조건 래치(뮤택스) 사용
        - 하나의 INSERT 쿼리에서 저장되는 레코드여도 연속된 자동 증가 값을 보장하지 않음
        - 유니크한 값이 생성된다는 것만 보장
        - STATEMENT 로그 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있음
        - 인터리빙 모드 (Interleaved mode)
    - MySQL 8.0 버전부터 기본 로그 포맷이 ROW이기 때문에 `innodb_autoinc_lock_mode`의 기본값이 2로 변경됨

### 5.3.2. 인덱스와 잠금
- InnoDB의 잠금은 레코드를 잠그는 것이 아닌 **인덱스를 잠그는 방식**
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠금
- **UPDATE 쿼리를 위해 적절한 인덱스가 없다면 탐색한 레코드에 잠금이 설정됨**
    - 동시성이 떨어짐
    - 인덱스가 하나도 없다면? -> full table scan -> 모든 레코드 잠금

### 5.3.3. 레코드 수준의 잠금 확인 및 해제
- 테이블 레코드 각각에 잠금이 걸리기 때문에 자주 사용되지 않는 레코드라면 오랜 시간 동안 잠겨진 상태여도 잘 발견되지 않음
- [5.3. InnoDB 스토리지 엔진 잠금](#53-innodb-스토리지-엔진-잠금)에서 `information_schema`의 정보들이 조금씩 deprecated되고 있기 때문에 `performance_schema` 데이터베이스의 `data_locks`와 `data_locks_wait` 테이블로 대체

## 5.4. MySQL의 격리 수준
- 여러 트랜잭션이 동시 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정
- `READ UNCOMMITTED`는 일반적인 데이터베이스에서 거의 사용하지 않음
- `SERIALIZABLE`은 동시성이 중요한 데이터베이스에서 거의 사용하지 않음
- `SERIALIZABLE` 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않음

||DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|
|--|--|--|--|
|READ UNCOMMITTED|O|O|O|
|READ COMMITTED|X|O|O|
|REPEATABLE READ|X|X|O (InnoDB X)|
|SERIALIZABLE|X|X|X|

### 5.4.1. READ UNCOMMITTED
- tx-1에서 커밋되지 않은 데이터를 tx-2에서 조회
- tx-1에서 롤백되더라도 tx-2는 이전 데이터를 그대로 사용
- dirty read 발생
- 정합성에 문제가 많음

### 5.4.2. READ COMMITTED
- tx-1에서 커밋한 데이터만 tx-2에서 조회
- tx-1에서 커밋하기 전이면 tx-2는 언두 로그에서 변경되기 전의 데이터를 조회
- tx-1에서 커밋하기 전에 tx-2에서 조회한 데이터와 커밋한 후에 조회한 데이터가 일치하지 않을 수 있음
- non-repeatable read 발생
- 트랜잭션 내에서 실행되는 SELECT와 트랜잭션 외부에서 실행되는 SELECT의 차이가 거의 없음

### 5.4.3. REPEATABLE READ
- 기본적으로 SELECT도 트랜잭션 범위 내에서만 동작
- 언두 로그와 MVCC 방식을 활용하여 동일한 트랜잭션 내에서 SELECT는 동일한 결과를 보장
- 모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가지고 있고, 언두 로그에 백업된 모든 레코드는 변경을 발생시킨 트랜잭션 번호를 포함
- MVCC를 보장하기 위해 현재 실행 중인 트랜잭션 중에서 가장 오래된 트랜잭션 번호보다 앞선 트랜잭션 번호의 언두 로그는 삭제할 수 없음
- tx-1(tx-id: 12)가 데이터 변경
- tx-2(tx-id: 10)는 자신의 트랜잭션 번호보다 작은 트랜잭션 번호의 언두 로그만 조회
- 하나의 레코드에 대해 여러 버전의 언두 로그가 발생하기 때문에 장시간 트랜잭션이 종료되지 않으면 언두 로그의 데이터가 무하넝 커질 수 있음
- `SELECT ... FOR UPDATE`나 `SELECT ... FOR SHARE`로 조회하면 언두 로그에는 잠금을 걸 수 없기 때문에 현재 레코드의 값을 가져옴
    - 이 때 phantom read 발생

### 5.4.4. SERIALIZABLE
- 가장 엄격한 격리 수준
- 동시 처리 성능도 다른 격리 수준보다 떨어짐
- 잠금이 필요없는 일관된 읽기를 허용하지 않음
    - 읽기 작업도 S-lock을 획득해야 함
    - 동시에 다른 트랜잭션은 해당 레코드에 쓰기 작업을 할 수 없음
- InnoDB 스토리지 엔진은 갭 락과 넥스트 키 락때문에 `REPEATABLE READ`에서도 phantom read가 발생하지 않음
    > 더 읽어볼 것
    > - https://medium.com/daangn/mysql-gap-lock-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0-7f47ea3f68bc
    > - https://parkmuhyeun.github.io/woowacourse/2023-11-28-Repeatable-Read/
